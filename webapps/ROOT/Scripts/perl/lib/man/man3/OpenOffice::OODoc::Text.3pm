.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OODoc::Text 3pm"
.TH OODoc::Text 3pm "2007-05-11" "perl v5.8.4" "User Contributed Perl Documentation"
.SH "NAME"
OpenOffice::OODoc::Text \- The text processing submodule of OpenOffice::OODoc
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This manual chapter describes the text-oriented methods of OpenOffice::OODoc,
implemented by the OpenOffice::OODoc::Text class, and inherited by the
OpenOffice::OODoc::Document class.
.PP
These methods are not essentially dedicated to string processing; they are
more precisely focused on text containers. A text container is a document
element which can (and must) be used in order to support a text and
integrate it at the right place and according to the right presentation rules.
The OpenDocument specification defines a lot of such containers, and the
present \s-1API\s0 supports many of them, such as paragraphs, headings, tables (or
spreadsheets), lists, sections, and draw pages. Some of these containers can
host other containers: for example, a table contains rows, a row contains
cells, a section can contain almost everything including other sections, etc.
.PP
These features are text\-oriented, but can be used on documents of any class,
such as spreadsheets or presentations as well as text documents. So, the
\&'Text' word doesn't mean that the features described in the present manual
chapter are dedicated to OpenDocument Text (\s-1ODT\s0) documents only. In the other
hand, a few methods can't apply to any document class (ex: creating or
retrieving draw pages makes sense with presentation and drawing documents
only).
.PP
OODoc::Text should not be explicitly used in an ordinary application, because
all its features are available through the OpenOffice::OODoc::Document class,
in combination with other features. Practically, the present manual is
provided to describe the text-oriented features of OpenOffice::OODoc::Document
(knowing that these features are technically supported by the
OpenOffice::OODoc::Text component of the \s-1API\s0).
.PP
The OpenOffice::OODoc::Text class is a specialist derivative of
OpenOffice::OODoc::XPath for \s-1XML\s0 elements which describe the text content
of OOo/ODF documents. Here, \*(L"text content\*(R" means containers that can
host text containers (i.e. tables, lists...) as well as flat text.
.PP
Knowing that the \*(L"styles.xml\*(R" member of an OpenDocument file can contain
text (because some style definitions, such as page headers or footers, can
contain text), the presently described features can be used against this
member as well as the \*(L"content.xml\*(R" member.
.PP
This module should be used in combination with OpenOffice::OODoc::Styles,
via the OpenOffice::OODoc::Document class, if the application has to handle
detailed presentation parameters of text elements. This is because such
parameters are held in styles elements and not in the text elements
themselves, according to the principle of separation of content and
presentation which is one of the foundations of the OpenDocument format.
.Sh "Methods"
.IX Subsection "Methods"
\fIConstructor : OpenOffice::OODoc::Text\->new(<parameters>)\fR
.IX Subsection "Constructor : OpenOffice::OODoc::Text->new(<parameters>)"
.PP
.Vb 1
\&        Short Form: ooText(<parameters>)
.Ve
.PP
.Vb 1
\&        See OpenOffice::OODoc::XPath->new
.Ve
.PP
.Vb 2
\&        Returns an OODoc::XPath OpenDocument connector with additional
\&        features mainly focused on text containers.
.Ve
.PP
.Vb 2
\&        This constructor is generally not explicitly called, knowing that
\&        it's automatically triggered each time a Document object is created.
.Ve
.PP
.Vb 2
\&        The XML member loaded by default is 'content.xml'. The most common
\&        creation method is like this:
.Ve
.PP
.Vb 1
\&            my $doc = ooText(file => 'my_file.odt');
.Ve
.PP
.Vb 2
\&        This constructor should generally not be called directly, because it's
\&        inherited by ooDocument().
.Ve
.PP
.Vb 2
\&        Other parameters can be supplied as options (see the properties list
\&        at the end of the chapter).
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 24
\&            my %delim =
\&                (
\&                'text:h'                =>
\&                        {
\&                        begin   => '\esect{',
\&                        end     => '}'
\&                        },
\&                'text:list-item'        =>
\&                        {
\&                        begin   => '\eitem'
\&                        }
\&                'text:footnote-body' =>
\&                        {
\&                        begin   => '\efootnote{',
\&                        end     => '}'
\&                        }
\&                );
\&            my $doc = ooText
\&                        (
\&                        file            => 'filename.odt',
\&                        paragraph_style => 'My Paragraphs',
\&                        heading_style   => 'My Headings',
\&                        delimiters      => { %delim }
\&                        );
.Ve
.PP
.Vb 6
\&        This technique gives the default styles to be used when creating new
\&        text elements. It also gives the particular delimiters (in this case
\&        LaTeX style markers) to be used at the beginning or end of some
\&        elements (in this case headings, list elements, footers) where the
\&        text is to be exported "as is". See the getText method of
\&        OODoc::Text for information about exporting text.
.Ve
.PP
\fIappendBodyElement(element [, options])\fR
.IX Subsection "appendBodyElement(element [, options])"
.PP
.Vb 2
\&        Copies an existing element of any type and appends it to the end of
\&        the document body. No new element is created.
.Ve
.PP
\fIappendDrawPage([options])\fR
.IX Subsection "appendDrawPage([options])"
.PP
.Vb 2
\&        In a presentation or drawing document, appends a new page at the en
\&        of the document.
.Ve
.PP
.Vb 1
\&        Possible options are:
.Ve
.PP
.Vb 4
\&                name            => page name (unique)
\&                id              => page numeric ID (unique)
\&                style           => page style name
\&                master          => master page name
.Ve
.PP
.Vb 1
\&        Returns the new draw page element if successful, undef if not.
.Ve
.PP
\fIappendHeading([options])\fR
.IX Subsection "appendHeading([options])"
.PP
.Vb 2
\&        Creates a new heading of any level and appends it to the end of the
\&        document.
.Ve
.PP
.Vb 1
\&        Options are given as a hash [key => value]:
.Ve
.PP
.Vb 3
\&            'text'              => <heading text>
\&            'level'             => heading level, default is 1
\&            'style'             => heading style, default is 'Heading 1'
.Ve
.PP
.Vb 1
\&        Examples:
.Ve
.PP
.Vb 1
\&            $doc->appendHeading(text => 'Next section');
.Ve
.PP
.Vb 1
\&        adds the text 'Next section' as a level 1 heading.
.Ve
.PP
.Vb 6
\&            $doc->appendHeading
\&                (
\&                text    => 'Chapter Conclusion',
\&                level   => '2',
\&                style   => 'Heading_20_2'
\&                );
.Ve
.PP
.Vb 3
\&        adds a level 2 heading to the end of the text body. 'Heading_20_n'
\&        styles, where 'n' is the level number, are presently available by
\&        default in OpenOffice.org.
.Ve
.PP
.Vb 4
\&        You can give any XML attribute to the new heading except for style or
\&        heading level. In this case, the program must construct a hash
\&        containing pairs of key-values for the attributes you want to create
\&        and pass it using the 'attribute' option. Example:
.Ve
.PP
.Vb 8
\&            my %attr    = ( 'att1' => 'value1', 'att2' => 'value2' );
\&            $doc->appendHeading
\&                (
\&                text    => 'Attributes are important',
\&                level   => '1',
\&                style   => 'Chapter heading',
\&                attribute => %attr
\&                );
.Ve
.PP
.Vb 2
\&        If the 'text' option is empty, the heading is created with an empty
\&        content.
.Ve
.PP
.Vb 6
\&        Caution, creating headings with level attributes is not always
\&        sufficient to produce the needed result. For example, in order to
\&        generate headings with appropriate levels of numbering, each one
\&        must be attached to the right position in a hierarchy of lists,
\&        in combination with appendItemList(), insertItemList(), and
\&        appendListItem().
.Ve
.PP
.Vb 5
\&        Note: this method can only be used with a new header i.e. it adds
\&        while it creates. To add an already available element using
\&        getHeading() from the same document or from another document, use
\&        the appendElement() method instead which is inherited from
\&        OODoc::XPath.
.Ve
.PP
\fIappendItem(list [, text => text ,style => style ,[other_options]])\fR
.IX Subsection "appendItem(list [, text => text ,style => style ,[other_options]])"
.PP
.Vb 1
\&        See appendListItem().
.Ve
.PP
\fIappendItemList([type => list_type, [style => style [, options]]])\fR
.IX Subsection "appendItemList([type => list_type, [style => style [, options]]])"
.PP
.Vb 2
\&        Creates a new (empty) list and appends it to the end of the
\&        document.
.Ve
.PP
.Vb 5
\&        In OpenOffice.org 1 documents, an unordered list is the default,
\&        and if the 'type' option is given with the value 'ordered', then an
\&        ordered list is created. In Open Documents, the 'type' option is
\&        ignored because there are generic lists only (a list is ordered or
\&        "bulleted" according to a style, and not natively).
.Ve
.PP
.Vb 3
\&        The 'style' options controls the list's style (as opposed to each
\&        item's style). If absent, the list takes the default paragraph style
\&        (see appendParagraph).
.Ve
.PP
.Vb 3
\&        Like appendParagraph, this method actually creates a new list
\&        element. To copy an existing list in the same document or in
\&        another, use appendElement or replicateElement instead.
.Ve
.PP
\fIappendListItem(list [, text => text ,style => style ,[other_options]])\fR
.IX Subsection "appendListItem(list [, text => text ,style => style ,[other_options]])"
.PP
.Vb 1
\&        Adds a new item to a list (ordered or unordered).
.Ve
.PP
.Vb 3
\&        The first argument is the existing list element (created using
\&        getOrderedList or getUnorderedList, for example). Options are the
\&        same as for appendParagraph.
.Ve
.PP
.Vb 2
\&        If the 'style' option is absent, the element is inserted according
\&        to the following rule:
.Ve
.PP
.Vb 2
\&        - if the new item is not the first one of the list, it takes the
\&        same style as the first item;
.Ve
.PP
.Vb 1
\&        - otherwise, it takes the default paragraph style of the document.
.Ve
.PP
.Vb 4
\&        The new item is created as a paragraph container by default. A
\&        'type' option may be provided in order to require another type.
\&        Possible values are 'header', 'paragraph' or the XML name of any
\&        OpenDocument-compliant text container.
.Ve
.PP
.Vb 4
\&        If the type is provided and set to undef, the new item is created
\&        as an empty element, so it could/should receive a content later.
\&        An empty item could be used as the attachment point of another
\&        list, in order to create a hierarchy of lists.
.Ve
.PP
\fIappendParagraph(<options>)\fR
.IX Subsection "appendParagraph(<options>)"
.PP
.Vb 1
\&        Creates a new paragraph and appends it to the document.
.Ve
.PP
.Vb 1
\&        Options:
.Ve
.PP
.Vb 2
\&            'text'              => <paragraph text>
\&            'style'             => <paragraph style>
.Ve
.PP
.Vb 2
\&        An 'attribute' option is also available under the same conditions as
\&        for the appendHeading method (see above).
.Ve
.PP
.Vb 2
\&        If the 'text' option is empty, calling this method is the equivalent
\&        of adding a line feed.
.Ve
.PP
.Vb 2
\&        If the 'style' option is empty, the style from the 'paragraph_style'
\&        property of the OODoc::Text instance is used.
.Ve
.PP
.Vb 5
\&        By default, the new paragraph takes place at the end of the document.
\&        But it's possible to attach it as the last child of an existing
\&        text container (ex: a table cell). To do so, the container must be
\&        provided through an 'attachment' option. For example, to append a new
\&        paragraph in a table cell, one can write
.Ve
.PP
.Vb 6
\&                my $cell = $doc->getCell("Table1", "B12");
\&                $doc->appendParagraph
\&                        (
\&                        text            => "The cell, reloaded",
\&                        attachment      => $cell
\&                        );
.Ve
.PP
.Vb 5
\&        Note: this method can only be used with a new paragraph i.e. it adds
\&        while it creates. To add an already existing paragraph using
\&        getParagraph from the same document or from another document, use
\&        the appendElement, insertElement or replicateElement methods instead
\&        which are inherited from OODoc::XPath.
.Ve
.PP
.Vb 3
\&        Note: The repeated spaces are not properly processed, so any sequence
\&        of spaces (whatever its length) in the 'text' string is replaced by a
\&        single space in the target document. See setText() and extendText().
.Ve
.PP
\fIappendRow(table [, options])\fR
.IX Subsection "appendRow(table [, options])"
.PP
.Vb 7
\&        Appends a row to the end of the given table either by reference, by
\&        logical name or by sequential number. By default, the new row is
\&        simply an exact copy of the preceding row (in terms of content and
\&        presentation). You can pass an options hash which will give certain
\&        attributes to the created row, under the same conditions as for the
\&        appendElement method of OODoc::XPath. The returned value is the
\&        created row element.
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 16
\&            open SRC, '<', 'data.txt';
\&            my $table = $doc->getTable("Table1");
\&            my ($h, $l) = $doc->getTableSize($table);
\&            for (my $i = 0 ; my $record = <SRC> ; $i++)
\&                {
\&                last unless $record;
\&                chomp $record;
\&                my @data = split ';', $record;
\&                my $row = $i < $h ?
\&                        $doc->getRow($table, $i) :
\&                        $doc->appendRow($table);
\&                for (my $j = 0 ; $j < $l ; $j++)
\&                        {
\&                        $doc->cellValue($row, $j, $data[$j]);
\&                        }
\&                }
.Ve
.PP
.Vb 10
\&        The above program reads a CSV format data file sequentially (one
\&        record per line, comma-separated fields). Each record is split and
\&        put into a row in table Table1. On reading each new record, the
\&        reference for the following row is loaded by getRow, until the total
\&        number of rows is reached (total obtained previously using
\&        getTableSize). If the table is already full, it is lengthened by a
\&        row using appendRow. The internal loop loads the read data into the
\&        row's cells (pre-existing or newly created). See the sections on
\&        getTable, getRow, getTableSize and cellValue for a better
\&        understanding of this example.
.Ve
.PP
.Vb 9
\&        However, if good performance is what you are after, massive
\&        repetition of this method is not recommended (e.g. for lengthening a
\&        table dynamically, row by row, whilst loading external data into
\&        it). Rather than running dozens or hundreds of successive
\&        appendRows, it would be better for the application to read the total
\&        number of records to be loaded (using, for example, select count if
\&        from a relational database or otherwise preloading the data into an
\&        ordinary Perl table) and create a table of appropriate size in
\&        advance using insertTable or appendTable.
.Ve
.PP
\fIappendSection(name [, options])\fR
.IX Subsection "appendSection(name [, options])"
.PP
.Vb 6
\&        Creates a new section with the given name, and appends it by default
\&        to the end of the document body. If the "attachment" option is
\&        provided, with an existing element as its value, the new section is
\&        appended in the context of this element. For example, if the value
\&        of "attachment" is an existing section, the new section is appended
\&        as the last sub-section of the existing one.
.Ve
.PP
.Vb 2
\&        A section may be used either to hold a local content or to insert
\&        a subdocument which can be reached through an external link.
.Ve
.PP
.Vb 4
\&        In order to insert a subdocument link instead of an ordinary section,
\&        the application must provide a "link" option whose value is either a
\&        local file path or an URL.
\&        Example:
.Ve
.PP
.Vb 5
\&            $doc->appendSection
\&                (
\&                "Article",
\&                link => "http://mycompany.com/doc/article.odt"
\&                );
.Ve
.PP
.Vb 1
\&        Other possible options:
.Ve
.PP
.Vb 11
\&            'style'     allows the application to explicitly select a style
\&                        for the new section
\&            'protected' write-protects the section when the document is
\&                        edited; "true" or "false", default "false"
\&            'key'       in combination with "protected" => "true", write-
\&                        protects the section by password (the value of
\&                        "key" is not the real password, but an encrypted
\&                        password, so the end-user will never remove the
\&                        protection by simply typing the key as it is
\&                        written in the program); see lockSection(),
\&                        unlockSection() and sectionProtectionKey()
.Ve
.PP
\fIappendTable(name, rows, columns [, options])\fR
.IX Subsection "appendTable(name, rows, columns [, options])"
.PP
.Vb 5
\&        Creates a new table with the given name, number of rows and number
\&        of columns, and appends it by default to the end of the document
\&        body. The name must be unique within the document (the call is
\&        rejected if the name already exists). Returns the created table
\&        element if successful.
.Ve
.PP
.Vb 2
\&        'rows' and/or 'columns', if omitted, are replaced by the 'max_rows'
\&        and 'max_cols' properties of the document (see the properties below).
.Ve
.PP
.Vb 3
\&        By default, the table is set to fit the entire width between the
\&        left and right margins with equal sized columns, cells of type
\&        string and without borders or background colour.
.Ve
.PP
.Vb 1
\&        Possible options:
.Ve
.PP
.Vb 4
\&            'table-style'       => table style
\&            'cell-type'         => default cell type
\&            'cell-style'        => default cell style
\&            'text-style'        => default cell text style
.Ve
.PP
.Vb 4
\&        The first option is the name of a table style which defines
\&        certain global properties for the table (width, background colour,
\&        etc.). See the OpenOffice::OODoc::Styles manual for information about
\&        styles.
.Ve
.PP
.Vb 12
\&        The second option is the cells' default data type. The main types
\&        available are string, float, currency, date, percentage. Caution: to
\&        be properly treated as having a numeric format in OOo/ODF, a
\&        cell needs more than to be just marked 'numeric'. If the cell really
\&        needs to be treated properly as a number, you must also give it a
\&        cell style which itself refers to a number style. The cell-style
\&        parameter can do this. However, even though the OODoc::Styles module
\&        is there to otherwise help you create and add styles from a program,
\&        this type of exercise can become very labour-intensive. We therefore
\&        recommend using basic tables created in advance from document
\&        templates or style libraries created from an office application,
\&        rather than creating complex number tables from code.
.Ve
.PP
.Vb 2
\&        The text-style option selects the paragraph style applicable to the
\&        text displayed in each cell.
.Ve
.PP
.Vb 2
\&        Once the table is created, you can obviously modify each cell's type
\&        and style individually.
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 6
\&            my $table = $doc->appendTable
\&                                (
\&                                "Rate", 22, 5,
\&                                'table-style' => 'Table1',
\&                                'text-style' => 'Text body'
\&                                );
.Ve
.PP
\fIappendTableRow(table)\fR
.IX Subsection "appendTableRow(table)"
.PP
.Vb 1
\&        See appendRow.
.Ve
.PP
\fIbibliographyEntryContent(id [, key1 => value1, key2 => value2, ...])\fR
.IX Subsection "bibliographyEntryContent(id [, key1 => value1, key2 => value2, ...])"
.PP
.Vb 3
\&        Gets, and optionally sets, the properties of a given (existing)
\&        bibliographic entry. The optionally updated properties are provides
\&        as a hash. The returned description is a hash.
.Ve
.PP
.Vb 3
\&        The first argument can be either the logical identifier of the entry
\&        (as it appears for the end-user) or a previously found bibliography
\&        entry element (see getBibliographyElements()).
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 6
\&                my %desc = $doc->bibliographyEntryContent
\&                                        (
\&                                        "GEN99",
\&                                        author  => 'Genicorp',
\&                                        pages   => 62
\&                                        );
.Ve
.PP
.Vb 2
\&        This sequence updates the "Author" and "Pages" values of the "GEN99"
\&        entry, then returns all the content of the entry in %desc.
.Ve
.PP
.Vb 5
\&        Caution: Several bibliography entries can have the same identifier.
\&        This method processes one element at a time. In the example above,
\&        only the first occurrence of the "GEN99" entries is updated. So, if
\&        the user needs to ensure that all the entries with the same identifier
\&        have the same content, the appropriate code should be something like:
.Ve
.PP
.Vb 10
\&                my @entries = $doc->getBibliographyElements("^GEN99$");
\&                foreach my $entry (@entries)
\&                        {
\&                        $doc->bibliographyEntryContent
\&                                (
\&                                $entry,
\&                                author  => 'Genicorp',
\&                                pages   => 62
\&                                )
\&                        }
.Ve
.PP
.Vb 5
\&        Caution: This method allows the user to create any new property and
\&        to put any value in any property, without control. For information
\&        about the legal and/or recommended properties, see the OpenDocument
\&        specification and the OpenOffice.org bibliographic project
\&        (http://bibliographic.openoffice.org).
.Ve
.PP
\fIbookmarkElement(element, name [, offset])\fR
.IX Subsection "bookmarkElement(element, name [, offset])"
.PP
.Vb 1
\&        See setBookmark().
.Ve
.PP
\fIcellCurrency(table, row, column [, currency])\fR
.IX Subsection "cellCurrency(table, row, column [, currency])"
.PP
\fIcellCurrency(cell [, currency])\fR
.IX Subsection "cellCurrency(cell [, currency])"
.PP
.Vb 3
\&        Get/set the currency unit of a cell.
\&        If a currency is provided, the cell value type is automatically
\&        switched to 'currency'.
.Ve
.PP
\fIcellFormula(table, row, column [, formula])\fR
.IX Subsection "cellFormula(table, row, column [, formula])"
.PP
\fIcellFormula(cell [, formula])\fR
.IX Subsection "cellFormula(cell [, formula])"
.PP
.Vb 2
\&        Accessor which returns the formula (or function) contained in the
\&        given table cell. Returns undef if no formula is found in the cell.
.Ve
.PP
.Vb 1
\&        The cell address is the same as for getCellValue().
.Ve
.PP
.Vb 4
\&        If a formula is given as the last argument, it is put into the cell,
\&        overwriting any existing formula. No check of the syntax is carried
\&        out on the inserted formula. It is up to the application to insert a
\&        formula which conforms to OOo/ODF syntax. Example:
.Ve
.PP
.Vb 1
\&            $doc->cellFormula(1,3,2, "sum <C2:C5>");
.Ve
.PP
.Vb 4
\&        Note 1: inserting or replacing a formula does not directly modify
\&        the value or text of the cell. Proper interpretation of a formula
\&        does not happen until the fields are updated when the document is
\&        reloaded into the office software.
.Ve
.PP
.Vb 2
\&        Note 2: syntax and functionality of cell formulae differ greatly
\&        between office applications.
.Ve
.PP
\fIcellSpan(table, row, column [, hspan [, vspan]])\fR
.IX Subsection "cellSpan(table, row, column [, hspan [, vspan]])"
.PP
\fIcellSpan(cell [, hspan [, vspan]])\fR
.IX Subsection "cellSpan(cell [, hspan [, vspan]])"
.PP
.Vb 4
\&        In a spreadsheet document, get/set the span of a table cell,
\&        knowing that this span can be one or more columns. The cell addressing
\&        is the same as with getCell().
\&        Example:
.Ve
.PP
.Vb 1
\&                $doc->cellSpan($table, "B4", 3);
.Ve
.PP
.Vb 1
\&        creates a 3-cell span from B4 in a spreadsheet.
.Ve
.PP
.Vb 5
\&        With only one span argument, this method works for horizontal, left to
\&        right expansion. With an additional argument, the expansion is bi-
\&        directional, covering one or more rows below the given cell. The
\&        horizontal span should be set to 1 in order to get a vertical span
\&        only.
.Ve
.PP
.Vb 2
\&        The text of the covered cells (if any) is concatenated to the original
\&        content of the expanded cell (as in OOo Writer or Calc).
.Ve
.PP
.Vb 4
\&        The user should make sure that the cell expansion will not invade the
\&        span of another, previously expanded cell. Assuming A is a the target
\&        of cellSpan(), B is an existing expanded cell, and C is a covered cell
\&        in the span of B, the following rules apply:
.Ve
.PP
.Vb 6
\&        If B is to be covered by the span of A, the span of B is automatically
\&        reset to 1, so C becomes visible, then B is covered by A. But if C is
\&        in the target range of cellSpan() while B is not, the method produces
\&        an inconsistency in the table (this inconsistency doesn't prevent
\&        OpenOffice.org and KSpread from loading the file but the span of A is
\&        just ignored).
.Ve
.PP
.Vb 2
\&        In list context, the method returns the horizontal span, then the
\&        vertical span. In scalar context, it returns the horizontal span only.
.Ve
.PP
.Vb 2
\&        Caution: when related to table cells, "span" has not the same
\&        meaning as when related to flat text (see getSpan() and setSpan()).
.Ve
.PP
\fIcellStyle(table, row, column [, stylename])\fR
.IX Subsection "cellStyle(table, row, column [, stylename])"
.PP
\fIcellStyle(cell [, stylename])\fR
.IX Subsection "cellStyle(cell [, stylename])"
.PP
.Vb 1
\&        Get or set the style of a table cell.
.Ve
.PP
\fIcellValue(table, row, column [, value [, text]])\fR
.IX Subsection "cellValue(table, row, column [, value [, text]])"
.PP
\fIcellValue(cell [, value [, text]])\fR
.IX Subsection "cellValue(cell [, value [, text]])"
.PP
.Vb 1
\&        Without the "value" argument: see getCellValue().
.Ve
.PP
.Vb 1
\&        With "value" (and, optionally, "text"): see updateCell().
.Ve
.PP
\fIcellValueType(table, row, column [, type])\fR
.IX Subsection "cellValueType(table, row, column [, type])"
.PP
\fIcellValueType(cell [, type])\fR
.IX Subsection "cellValueType(cell [, type])"
.PP
.Vb 1
\&        Get/set the data type of a table cell.
.Ve
.PP
.Vb 2
\&        Possible value types are 'string', 'float', 'percentage', 'currency',
\&        'date', 'time', 'boolean'.
.Ve
.PP
.Vb 3
\&        Note: If an application must convert a 'string' cell to a numeric
\&        one and fill it with a numeric value, cellValueType() must be called
\&        *before* cellValue(). Ex:
.Ve
.PP
.Vb 3
\&                my $cell = $doc->getCell('Sheet1', 4, 8);
\&                $doc->cellValueType($cell, 'float');
\&                $doc->cellValue($cell, 12.34);
.Ve
.PP
\fIcolumnStyle(column_element [, style])\fR
.IX Subsection "columnStyle(column_element [, style])"
.PP
\fIcolumnStyle(table, column [, style])\fR
.IX Subsection "columnStyle(table, column [, style])"
.PP
.Vb 5
\&        Returns the style name of the given column or replaces it with a new
\&        one. A column can be indicated either directly by reference or by
\&        the pair [table, column number]. The table itself can be indicated
\&        either by a table element, its number or its logical name. If the
\&        'style' argument is given, it replaces the old column style.
.Ve
.PP
.Vb 2
\&        Giving a column a style is actually the only way to control the
\&        width of a column in a table.
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 1
\&            $doc->columnStyle('Table1', 2, 'NewStyle');
.Ve
.PP
.Vb 1
\&        Caution: columns are numbered beginning at 0.
.Ve
.PP
\fIcopyRowToHeader(table, rownum)\fR
.IX Subsection "copyRowToHeader(table, rownum)"
.PP
\fIcopyRowToHeader(row)\fR
.IX Subsection "copyRowToHeader(row)"
.PP
.Vb 3
\&        This method appends a copy of a given table row to the header of the
\&        table. It may be called repeatedly, allowing multi-row header
\&        creation.
.Ve
.PP
.Vb 3
\&        A table header is a row, or a sequence of rows, that is displayed at
\&        the top of a table and repeated at the top of every page if the table
\&        is spanned across more than one page.
.Ve
.PP
.Vb 2
\&        The given row remains in place unchanged; it's used as a template for
\&        the new header row.
.Ve
.PP
\fIcreateParagraph([text [, style]])\fR
.IX Subsection "createParagraph([text [, style]])"
.PP
.Vb 3
\&        Creates a free paragraph for later use. Unlike appendParagraph() or
\&        insertParagraph(), this method doesn't attach the new paragraph to
\&        the document.
.Ve
.PP
.Vb 4
\&        Without arguments, the paragraph is created empty. The first argument,
\&        if any, provides the text content of the paragraph. The second one,
\&        if any, is regarded as the style name; the default style is
\&        "Standard".
.Ve
.PP
\fIcreateTextBox(options)\fR
.IX Subsection "createTextBox(options)"
.PP
.Vb 3
\&        Creates a new text box. Can apply to any document class, but mostly
\&        used in presentations or drawings (where text boxes are required to
\&        host text content).
.Ve
.PP
.Vb 3
\&        Text boxes are implemented through frame element, so you should see
\&        createFrame() in the OpenOffice::OODoc::XPath manual chapter in order
\&        to understand the meaning of every option.
.Ve
.PP
.Vb 2
\&        The following options are allowed (and generally required in order
\&        to make a text box really visible and properly rendered):
.Ve
.PP
.Vb 2
\&        page: the page where the box must be attached; in presentations or
\&        drawings, this option should be set with the page name;
.Ve
.PP
.Vb 1
\&        name: the (unique) name of the text box;
.Ve
.PP
.Vb 1
\&        size: the size of the box;
.Ve
.PP
.Vb 1
\&        position: the page-relative position;
.Ve
.PP
.Vb 2
\&        style: the graphic style of the box; like an image box, a text box
\&        often requires a style to be properly displayed;
.Ve
.PP
.Vb 5
\&        content: the content to be displayed in the box; if this option is
\&        set to a literal, the given content is inserted as a paragraph in
\&        the box; if the given value is the reference of an element, this
\&        element is attached as is in the box (so it's possible to insert
\&        any complex object, such as a table, an item list, etc).
.Ve
.PP
.Vb 1
\&        The method returns the reference of the new text box element.
.Ve
.PP
.Vb 6
\&        The example below creates an graphic style ("TB"), then a text box
\&        ("The Box") which uses the new style. See O::O::Styles for comments
\&        about createStyle(). The text box is attached in a presentation page
\&        identified by its name ("AnyPageName"). The size (width then height)
\&        and position (x, y) options are provided in centimeters (other units
\&        are allowed), each one in a single string.
.Ve
.PP
.Vb 22
\&                $doc->createStyle
\&                        (
\&                        "TB",
\&                        family          => "graphic",
\&                        parent          => "objectwithshadow",
\&                        properties      =>
\&                                {
\&                                'style:vertical-pos'    => 'from-top',
\&                                'style:horizontal-pos'  => 'from-left',
\&                                'style:vertical-rel'    => 'page',
\&                                'style:horizontal-rel'  => 'page'
\&                                }
\&                        );
\&                $doc->createTextBox
\&                        (
\&                        page            => "AnyPageName",
\&                        name            => "The Box",
\&                        size            => '12cm, 4cm',
\&                        position        => '8cm, 14cm',
\&                        style           => 'TB',
\&                        content         => "The text in the box"
\&                        );
.Ve
.PP
.Vb 5
\&        In this example, the content option is set to a flat text, so
\&        it will be inserted as a standard paragraph. If we want to insert
\&        a paragraph with a non-default style, this option must be set to
\&        the reference of an existing paragraph (which may have been created
\&        using createParagraph() or copied from another place).
.Ve
.PP
\fIdefaultOutputTerminator([chars])\fR
.IX Subsection "defaultOutputTerminator([chars])"
.PP
.Vb 2
\&        Get or set the default terminator character for text export.
\&        Example:
.Ve
.PP
.Vb 1
\&                $doc->defaultOutputTerminator("\en");
.Ve
.PP
.Vb 3
\&        After this instruction, a line-break will be appended at the end of
\&        every paragraph or header exported by getText(), selectTextContent()
\&        or other text extracting methods.
.Ve
.PP
.Vb 2
\&        To reverse this behaviour, the user can call this method with an
\&        empty string.
.Ve
.PP
.Vb 1
\&        Without argument, returns the currently selected terminator, if any.
.Ve
.PP
\fIdeleteBookmark(name)\fR
.IX Subsection "deleteBookmark(name)"
.PP
.Vb 1
\&        Deletes the given bookmark (if defined).
.Ve
.PP
.Vb 1
\&        Works with position bookmarks only.
.Ve
.PP
\fIdeleteColumn(table, col_num)\fR
.IX Subsection "deleteColumn(table, col_num)"
.PP
\fIdeleteColumn(col_elt)\fR
.IX Subsection "deleteColumn(col_elt)"
.PP
.Vb 1
\&        Deletes a given column in a given table.
.Ve
.PP
.Vb 4
\&        Caution: Before using this method, the application should ensure that
\&        the whole area from the beginning of the table to the last cell of the
\&        column to be deleted is "normalized". See normalizeSheet() for details
\&        about table normalization.
.Ve
.PP
\fI\fIdeleteHeading()\fI\fR
.IX Subsection "deleteHeading()"
.PP
.Vb 1
\&        See removeHeading().
.Ve
.PP
\fIdeleteRow(table, row_num)\fR
.IX Subsection "deleteRow(table, row_num)"
.PP
\fIdeleteRow(row_elt)\fR
.IX Subsection "deleteRow(row_elt)"
.PP
.Vb 1
\&        Deletes a given row in a table.
.Ve
.PP
\fIdrawPageId(page [, new_id])\fR
.IX Subsection "drawPageId(page [, new_id])"
.PP
.Vb 3
\&        Returns the internal identifier of a presentation page, and changes
\&        it if a second argument is provided. The page id is a positive
\&        integer.
.Ve
.PP
.Vb 1
\&        The first argument must comply to the same rules as with getDrawPage.
.Ve
.PP
\fIdrawPageName(page [, newname])\fR
.IX Subsection "drawPageName(page [, newname])"
.PP
.Vb 4
\&        Returns the visible name of a presentation or drawing page.
\&        The first argument can be a page order number, a page element or the
\&        present page name (see getDrawPage). The page is renamed if a
\&        second argument is provided. Example:
.Ve
.PP
.Vb 1
\&                $doc->drawPageName("oldname", "newname");
.Ve
.PP
\fIdeleteTableColumn(table, col_num)\fR
.IX Subsection "deleteTableColumn(table, col_num)"
.PP
.Vb 1
\&        See deleteColumn().
.Ve
.PP
\fIdeleteTableRow(table, row_num)\fR
.IX Subsection "deleteTableRow(table, row_num)"
.PP
.Vb 1
\&        See deleteRow().
.Ve
.PP
\fIextendText(element, text [, style [, offset]])\fR
.IX Subsection "extendText(element, text [, style [, offset]])"
.PP
.Vb 3
\&        Inserts the text provided as the second argument into the element
\&        specified by the first argument. The second argument may be either a
\&        flat string or another existing text element.
.Ve
.PP
.Vb 4
\&        If the 'text' argument is a paragraph or heading element, the text
\&        content (and not the element itself) is inserted. But if 'text' is
\&        any other element (for example: a variable text field or a sequence
\&        of spaces), its inserted as is.
.Ve
.PP
.Vb 2
\&        This method is an improvement of the general extendText() method
\&        which is documented in the OpenOffice::OODoc::XPath manual page.
.Ve
.PP
.Vb 5
\&        If a third argument is provided and is neither 0 nor an empty string,
\&        it's regarded as the desired style of the new text, which is inserted
\&        as a "styled span" (see setSpan() for details about text "spans").
\&        By default, the text is inserted without any special style (i.e. with
\&        the same style as the containing element).
.Ve
.PP
.Vb 6
\&        The new text is, by default, appended to the existing content of the
\&        element. However, if a valid numeric value is provided as the fourth
\&        argument, the new text is inserted within the existing content, at the
\&        given offset. If the offset is negative, it's counted backwards from
\&        the end of the string. If it's set to 0, the insertion takes place at
\&        the beginning.
.Ve
.PP
.Vb 12
\&                $doc->createStyle
\&                        (
\&                        "BlueYellow",
\&                        family          => "text",
\&                        properties      =>
\&                            {
\&                            "fo:color"                  => odfColor("blue"),
\&                            "fo:background-color"       => odfColor("yellow")
\&                            }
\&                        );
\&                my $p = $doc->getParagraph(4);
\&                $doc->extendText($p, "New text", "BlueYellow", 5);
.Ve
.PP
.Vb 2
\&        In the example above, "New text" is inserted at the offset 5 within
\&        the 5th paragraph, in blue letters on a yellow background.
.Ve
.PP
.Vb 4
\&        Of course, the offset argument can't be passed unless the style one is
\&        present. However, in order to pass an offset without setting a style,
\&        the application has just to provide a 0 or an empty string as the
\&        third argument. Example:
.Ve
.PP
.Vb 1
\&                $doc->extendText($p, "New text", "", 5);
.Ve
.PP
.Vb 4
\&        Every string inserted through this method looks like it had always
\&        been a part of the original string when edited using OOo. However,
\&        each one remains stored in a separate space, like a "styled text
\&        span" (see setSpan()). So, given the following example:
.Ve
.PP
.Vb 2
\&                $doc->setText($para, "Old");
\&                $doc->extendText($para, "New");
.Ve
.PP
.Vb 10
\&        After this sequence, the displayable content of $para is "OldNew",
\&        but "OldNew" is not retrievable by selectElementsByContent(),
\&        setSpan(), or other text-searching methods, because "Old" and "New"
\&        are physically stored in separate containers (each one can have a
\&        distinct style). In addition, a subsequent call of extendText()
\&        with an offset on the same target will not properly work if the
\&        offset value is greater than the initial length (3 in the example).
\&        However, all the internal text span borders may be removed by an
\&        explicit call of flatten(). So, a third instruction could be
\&        appended to the example:
.Ve
.PP
.Vb 1
\&                $doc->flatten($para);
.Ve
.PP
.Vb 5
\&        After this last instruction, the whole content of $para is stored
\&        as a single string, and there is no internal separation between the
\&        original content and the extension(s). In the other hand, flatten()
\&        removes any previous formatting markup as well. For details about
\&        flatten(), see OpenOffice::OODoc::XPath.
.Ve
.PP
\fIgetBibliographyElements([id])\fR
.IX Subsection "getBibliographyElements([id])"
.PP
.Vb 2
\&        Returns the list of the bibliographic entry elements contained in the
\&        document.
.Ve
.PP
.Vb 2
\&        If an argument is provided, the returned list is restricted to the
\&        bibliographic entries matching it (this argument can be a regexp).
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 1
\&                my @biblio = $doc->getBibliographyElements("^W3C");
.Ve
.PP
.Vb 2
\&        returns the bibliographic entries where the identifier begins with
\&        "W3C".
.Ve
.PP
\fIgetBookmark(name)\fR
.IX Subsection "getBookmark(name)"
.PP
.Vb 2
\&        Returns the bookmark element (if defined) corresponding to the given
\&        bookmark name.
.Ve
.PP
.Vb 2
\&        If the bookmark covers a range of text (i.e. if it's not a position),
\&        the returned element is the "bookmark start" one.
.Ve
.PP
\fIgetCell(table, row, column)\fR
.IX Subsection "getCell(table, row, column)"
.PP
\fIgetCell(table, coord)\fR
.IX Subsection "getCell(table, coord)"
.PP
\fIgetCell(row, column)\fR
.IX Subsection "getCell(row, column)"
.PP
.Vb 6
\&        Returns the element which represents the given cell. Possible
\&        arguments are respectively: the table number or its reference in the
\&        document, row number and column number. Each table cell contained in
\&        the body of an OOo/ODF document can be referenced in this
\&        manner, as if it belonged to a single 3D table irrespective of the
\&        rest of the document.
.Ve
.PP
.Vb 3
\&        If the cell is defined in the spreadsheet but covered (because of a
\&        cell merge), the return value is undef. In other words, this method
\&        doesn't provide access to a covered cell.
.Ve
.PP
.Vb 10
\&        The first argument can be either the sequential number of the table
\&        (starting at 0), the logical name of the table, or a 'table' object
\&        (which can be retrieved in advance using getTable). If it's a number
\&        or a name, getTable() is automatically called by getCell() in order
\&        to convert it in a 'table' object. However, if the first argument is
\&        a row object (previously obtained via getRow() or getHeaderRow()),
\&        the second one is processed as the column number. Before using several
\&        cells in the same row, it's a good idea to get the row object and then
\&        to use it in every cell selection, in order to minimize the
\&        coordinates calculation.
.Ve
.PP
.Vb 4
\&        In tables including one or more header rows, the best way to get a
\&        header cell is to use a header row (previously obtained using
\&        getHeaderRow()) as the first argument. If the first argument is a
\&        table, getCell() looks in the table body only.
.Ve
.PP
.Vb 4
\&        Alternatively, the user can provide the cell coordinates in a single
\&        alphanumeric argument, beginning with one or two letters and ending
\&        with one or more decimal digits, according to the same logic as in a
\&        spreadsheet. So, for example
.Ve
.PP
.Vb 1
\&                $doc->getCell($table, 'B12');
.Ve
.PP
.Vb 1
\&        is equivalent to
.Ve
.PP
.Vb 1
\&                $doc->getCell($table, 11, 1);
.Ve
.PP
.Vb 3
\&        (Remember that, with the numeric coordinates, the row number is the
\&        first argument, while with the alphanumeric, spreadsheet-like ones,
\&        the column letter(s) come first.)
.Ve
.PP
.Vb 2
\&        Numbers can also be negative, where position -1 is the last. For
\&        example:
.Ve
.PP
.Vb 1
\&            $cell = $doc->getCell(-1, -1, -1);
.Ve
.PP
.Vb 2
\&        returns the very bottom right cell of the very last table in the
\&        document $doc.
.Ve
.PP
.Vb 2
\&        Returns a null value if the given cell does not exist or if it's
\&        covered by the span of another cell.
.Ve
.PP
.Vb 2
\&        Any cellXXX() method in this module uses the same cell addressing
\&        logic as getCell().
.Ve
.PP
.Vb 9
\&        CAUTION: Remember that OODoc works with the XML representation of
\&        the tables, and not with the tables themselves. The [x,y] direct
\&        addressing feature works as long as there is a continuous, one-to-one
\&        mapping between the logical view and the physical XML storage of the
\&        table. But, according to the OpenDocument specification, several
\&        contiguous objects (cells or rows) are allowed to be mapped to a
\&        single XML object when they have the same content and the same
\&        style, in order to save some storage space. This optimization is
\&        systematically used, for example, by OpenOffice.org Calc.
.Ve
.PP
.Vb 7
\&        Addressing cells in spreadsheets is considerably more complex
\&        than in text document tables. However, the same addressing scheme
\&        in allowed in the "Calc" documents than in the "Writer" ones,
\&        provided the targeted cells belong to a preprocessed workspace
\&        (beginning at the upper-left cell, and ending at a parametrizable
\&        position). It's possible to use normalizeSheet() or getTable() in
\&        order to make this workspace available.
.Ve
.PP
.Vb 1
\&        See normalizeSheet() for more explanations.
.Ve
.PP
.Vb 3
\&        Remember that the table addressing is zero-based and
\&        the row comes before the column in OpenOffice::OODoc, so, for
\&        example:
.Ve
.PP
.Vb 2
\&                $cell1 = $doc->getCell($table, 0, 0);
\&                $cell2 = $doc->getCell($table, 31, 25);
.Ve
.PP
.Vb 1
\&        returns respectively the A1 and Z32 cells.
.Ve
.PP
.Vb 2
\&        Note: in a spreadsheet, (0,0) are the coordinates of the "A1" cell,
\&        and, for example, (16, 25) are the coordinates of the "Z17" cell.
.Ve
.PP
\fIgetCellParagraph(table, row, column)\fR
.IX Subsection "getCellParagraph(table, row, column)"
.PP
\fIgetCellParagraph(cell)\fR
.IX Subsection "getCellParagraph(cell)"
.PP
.Vb 3
\&        Returns the paragraph element contained in a given table cell, if
\&        the cell contains a paragraph. If the cell contains more than one
\&        paragraph, returns the first one.
.Ve
.PP
\fIgetCellParagraphs(table, row, column)\fR
.IX Subsection "getCellParagraphs(table, row, column)"
.PP
\fIgetCellParagraphs(cell)\fR
.IX Subsection "getCellParagraphs(cell)"
.PP
.Vb 3
\&        Returns the list of the paragraph elements contained in a given
\&        table cell (knowing that a single cell can contain one or more
\&        paragraphs).
.Ve
.PP
\fIgetCellValue(table, row, column)\fR
.IX Subsection "getCellValue(table, row, column)"
.PP
\fIgetCellValue(cell)\fR
.IX Subsection "getCellValue(cell)"
.PP
.Vb 3
\&        Returns the value of a table cell, if the cell is defined and
\&        uncovered. Caution, in order to get the cell element itself for
\&        further processing, use getCell() instead.
.Ve
.PP
.Vb 2
\&        The first form indicates a cell by its 3D coordinates, as with
\&        getCell().
.Ve
.PP
.Vb 2
\&        The second form (quicker) takes a cell element as its only argument
\&        (e.g. as returned by a previous getCell call).
.Ve
.PP
.Vb 5
\&        This method behaves in two different ways depending on the cell
\&        type. The displayable text of the cell is regarded as the cell value
\&        if the cell type is 'string'. If the cell type is one of the possible
\&        numeric types ('float', 'currency', 'date'), the returned value is the
\&        internal, numeric value.
.Ve
.PP
.Vb 2
\&        This difference in handling is designed to allow programs to use
\&        returned numeric values directly in calculations.
.Ve
.PP
.Vb 1
\&        See also cellValueType().
.Ve
.PP
.Vb 3
\&        Note: To get information about a cell other than its value or value
\&        type (numeric, etc.), the best way is first to get its element
\&        reference with getCell() and then use it with getAttribute.
.Ve
.PP
\fIgetChapterContent(heading [, options])\fR
.IX Subsection "getChapterContent(heading [, options])"
.PP
.Vb 4
\&        This method returns the list of the elements depending (from the
\&        end-user's point of view) on a given heading element, not including
\&        the heading element itself. The argument and the options are the
\&        same as with getHeading().
.Ve
.PP
.Vb 1
\&        Examples:
.Ve
.PP
.Vb 6
\&                my @list = $doc->getChapterContent(2, level => 3);
\&                foreach my $element (@list)
\&                        {
\&                        my $text = $doc->getText($element);
\&                        print "$text\en";
\&                        }
.Ve
.PP
.Vb 5
\&        The code above selects and prints all the text elements below the
\&        third level 3 heading of the document (not including the content of
\&        the header itself. The following example creates a new section whose
\&        content is made of a heading and the content of the depending chapter
\&        (the heading text is used as the section name):
.Ve
.PP
.Vb 5
\&                my $heading = $doc->getHeading(2, level => 3);
\&                my $heading_text = $doc->getFlatText($heading);
\&                my $section = $doc->appendSection($heading_text);
\&                my @content = $doc->getChapterBodyElements($heading);
\&                $doc->moveElementsToSection($section, $heading, @content);
.Ve
.PP
.Vb 2
\&        (See appendSection(), getHeading(), moveElementsToSection() in the
\&        present manual chapter, and getFlatText() in OpenOffice::OODoc::XPath)
.Ve
.PP
.Vb 5
\&        Caution, this method returns a list of elements and not an element.
\&        Chapters, unlike sections, are not defined in OpenDocument. So,
\&        getChapterContent() should be used as a possible workaround in order
\&        to isolate a logical set of content elements which is not packaged in
\&        a section.
.Ve
.PP
\fIgetColumn(table, column)\fR
.IX Subsection "getColumn(table, column)"
.PP
.Vb 4
\&        Returns the element reference of the given column in the given
\&        table. The first argument is either the table's sequential number in
\&        the document, logical name or element reference. The second argument
\&        is the column's number in the table. Synonym: getTableColumn.
.Ve
.PP
.Vb 3
\&        Caution: The application should ensure that the area including the
\&        needed column is "normalized". See normalizeSheet() for details about
\&        table normalization.
.Ve
.PP
\fIgetDrawPage(pos/name)\fR
.IX Subsection "getDrawPage(pos/name)"
.PP
.Vb 1
\&        For presentation and drawing documents.
.Ve
.PP
.Vb 1
\&        Returns the element reference of the given page name or position.
.Ve
.PP
.Vb 3
\&        If the argument contains an integer, the page is selected according to
\&        its zero-based position. If the value is negative, the position is
\&        counted backwards from the end.
.Ve
.PP
.Vb 2
\&        If the argument is alphanumeric, it's regarded as a page name, and the
\&        page is selected accordingly.
.Ve
.PP
.Vb 3
\&        Caution: This method can't retrieve a page by name if the name
\&        contains numeric characters only; selectDrawPageByName() should be
\&        preferred to do so.
.Ve
.PP
\fI\fIgetEndnoteCitationList()\fI\fR
.IX Subsection "getEndnoteCitationList()"
.PP
.Vb 2
\&        Returns the list of all the endnote citations (i.e. references to
\&        footnotes included in the text) contained in the document.
.Ve
.PP
\fI\fIgetEndnoteList()\fI\fR
.IX Subsection "getEndnoteList()"
.PP
.Vb 3
\&        Returns the list of all the endnote body elements contained in the
\&        document. Should be replaced by getNoteList() with the "class" option
\&        set to "endnote".
.Ve
.PP
\fI\fIgetFootnoteCitationList()\fI\fR
.IX Subsection "getFootnoteCitationList()"
.PP
.Vb 2
\&        Returns the list of all the footnote citations (i.e. references to
\&        footnotes included in the text) contained in the document.
.Ve
.PP
\fI\fIgetFootnoteList()\fI\fR
.IX Subsection "getFootnoteList()"
.PP
.Vb 3
\&        Returns the list of all the footnote body elements contained in the
\&        document. Should be replaced by getNoteList() with the "class" option
\&        set to "footnote".
.Ve
.PP
\fIgetHeading(n [, options])\fR
.IX Subsection "getHeading(n [, options])"
.PP
.Vb 1
\&        Returns the nth+1 heading element.
.Ve
.PP
.Vb 2
\&        If n is negative, headings are counted backwards from the last.
\&        getHeader(-1) returns the last heading element of the document.
.Ve
.PP
.Vb 2
\&        The only one possible option is "level". It allows the application
\&        to select the nth+1 heading element for a given level.
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 1
\&                my $heading = $doc->getHeading(2, level => 3);
.Ve
.PP
.Vb 1
\&        selects the third level 3 heading in the whole document.
.Ve
.PP
.Vb 1
\&        See also getChapterContent().
.Ve
.PP
.Vb 5
\&        Caution: without the "level" option, this method counts sequentially
\&        through all headings along a single plane, irrespective of their
\&        level. E.g. if you have a level 1 heading then two level 2 headings
\&        then a level 1 heading, the call getHeading(3) returns the last
\&        level 1 heading.
.Ve
.PP
\fIgetHeadingList([level => value])\fR
.IX Subsection "getHeadingList([level => value])"
.PP
.Vb 2
\&        Returns a list of heading elements (i.e. elements called 'text:h' in
\&        the document body).
.Ve
.PP
.Vb 2
\&        If the "level" option is provided, the list is restricted to the
\&        headings having the given level.
.Ve
.PP
\fIgetHeaderRow(table [, row_number])\fR
.IX Subsection "getHeaderRow(table [, row_number])"
.PP
.Vb 1
\&        See getTableHeaderRow().
.Ve
.PP
\fIgetHeadingText(n)\fR
.IX Subsection "getHeadingText(n)"
.PP
.Vb 2
\&        Returns the text of the nth+1 heading element. Elements are counted
\&        in the same way as for getHeading().
.Ve
.PP
\fI\fIgetHeadingTextList()\fI\fR
.IX Subsection "getHeadingTextList()"
.PP
.Vb 1
\&        Returns a list of document heading texts.
.Ve
.PP
.Vb 4
\&        In a list context, the result is returned in the form of a list of
\&        character strings. In a scalar context, the result is a single
\&        string in which the headings are separated by a line-break character
\&        ("\en").
.Ve
.PP
.Vb 4
\&        Note: This list is "flat". It contains no information about the
\&        headings' hierarchy. To get a hierarchical contents list, you must
\&        start with the list of headings obtained using getHeadingList and
\&        check each element's level attribute ('text:level').
.Ve
.PP
\fIgetItemElementList(list)\fR
.IX Subsection "getItemElementList(list)"
.PP
.Vb 5
\&        Returns a list of elements which represent items of an ordered or
\&        unordered list. The argument is a "list" element (obtained
\&        previously e.g. using getItemList, getOrderedList or
\&        getUnorderedList). Each element in this list can be used with item
\&        handling methods.
.Ve
.PP
\fIgetItemList(n)\fR
.IX Subsection "getItemList(n)"
.PP
.Vb 2
\&        Returns the element which represents the nth+1 list in a document
\&        if found.
.Ve
.PP
.Vb 5
\&        WARNING: In the OpenOffice.org 1 documents, only "ordered lists" and
\&        "unordered lists" can be present. In the Open Document format, there
\&        are generic list objects only, and each one is made "ordered" or
\&        "unordered" by its style. So, this method will never return anything
\&        from an OOo 1 document.
.Ve
.PP
\fIgetLevel(element)\fR
.IX Subsection "getLevel(element)"
.PP
.Vb 1
\&        See getOutlineLevel().
.Ve
.PP
\fIgetList(n)\fR
.IX Subsection "getList(n)"
.PP
.Vb 1
\&        See getItemList().
.Ve
.PP
\fIgetListItem(list, n)\fR
.IX Subsection "getListItem(list, n)"
.PP
.Vb 1
\&        Returns the nth+1 item in a given list if found.
.Ve
.PP
.Vb 2
\&        The list (1st argument) may be given either by its order number in
\&        the document, or directly as an element reference.
.Ve
.PP
\fI\fIgetNoteCitationList()\fI\fR
.IX Subsection "getNoteCitationList()"
.PP
.Vb 1
\&        For OpenDocument only (doesn't work on old OpenOffice.org documents).
.Ve
.PP
.Vb 2
\&        Returns the list of all the note citation elements (whatever their
\&        note class, i.e. "endnote" or "footnote").
.Ve
.PP
\fIgetNoteClass(note_element)\fR
.IX Subsection "getNoteClass(note_element)"
.PP
.Vb 3
\&        Returns the class of the given note element. Possible values are
\&        presently "endnote" and "footnote". Returns undef unless the given
\&        element is a note.
.Ve
.PP
\fIgetNoteElement(class => \f(CI$note_class\fI, citation => \f(CI$note_citation\fI)\fR
.IX Subsection "getNoteElement(class => $note_class, citation => $note_citation)"
.PP
.Vb 2
\&        Returns the first note element matching the given class and citation,
\&        if any. Returns undef if the target note element doesn't exist.
.Ve
.PP
.Vb 1
\&        The "class" parameter is either "endnote" or "footnote".
.Ve
.PP
.Vb 2
\&        The "citation" parameter is the numeric or literal which refers to
\&        the note, as it's visible for the end user.
.Ve
.PP
.Vb 8
\&        Caution: The uniqueness of a note citation in a given note class is
\&        not a general rule. The citation is an identifier when it belongs to
\&        an ordered sequence (such as 1, 2, 3... or "i", "ii", "iii"...). But
\&        the author is allowed to use the same citation (ex: an asterisk) for
\&        more than one footnote or endnote. In such a situation, the method
\&        returns the first note matching the given citation and the given
\&        class. As a consequence, the note identifier, if known, is a better
\&        option (see the second form of getNoteElement()).
.Ve
.PP
\fIgetNoteElement(id => \f(CI$note_identifier\fI)\fR
.IX Subsection "getNoteElement(id => $note_identifier)"
.PP
.Vb 2
\&        Returns the note element matching the given internal note identifier
\&        (which is a "text:id" attribute according to the ODF specification).
.Ve
.PP
.Vb 4
\&        This internal identifier is unique, whatever the note class, so the
\&        "class" parameter is not needed. However, "class" may be provided as
\&        an additional filter; if so, the method will return undef if the
\&        element matching the identifier doesn't match the class.
.Ve
.PP
\fI\fIgetNoteElementList()\fI\fR
.IX Subsection "getNoteElementList()"
.PP
.Vb 1
\&        Returns the list of the endnote and footnote main elements.
.Ve
.PP
\fI\fIgetNoteList()\fI\fR
.IX Subsection "getNoteList()"
.PP
.Vb 1
\&        Returns the list of the endnote and footnote body elements.
.Ve
.PP
\fIgetOrderedList(n)\fR
.IX Subsection "getOrderedList(n)"
.PP
.Vb 2
\&        Returns the element which represents the nth+1 ordered list in a
\&        document if found.
.Ve
.PP
.Vb 2
\&        WARNING: Ordered lists are possible in the OpenOffice.org 1 format
\&        only. Don't use it against OpenDocument.
.Ve
.PP
\fIgetOutlineLevel(element)\fR
.IX Subsection "getOutlineLevel(element)"
.PP
.Vb 3
\&        Returns the level number of a text element, or undef if the given
\&        element don't have a level number. Every heading element should have
\&        a level, while ordinary text body elements should not. Example:
.Ve
.PP
.Vb 9
\&                my $level = $doc->getOutlineLevel($element);
\&                if ($level)
\&                        {
\&                        print "There is a level $level heading\en";
\&                        }
\&                else
\&                        {
\&                        print "Non-heading element\en";
\&                        }
.Ve
.PP
\fIgetParagraph(n)\fR
.IX Subsection "getParagraph(n)"
.PP
.Vb 3
\&        Returns the nth+1 paragraph in the document body, or undef if the
\&        given number is greater than or equal to the total number of
\&        paragraphs in the document.
.Ve
.PP
.Vb 2
\&        You can also pass a negative argument, in which case paragraphs are
\&        counted backwards from the end (-1 being the last paragraph).
.Ve
.PP
.Vb 3
\&        By paragraphs we mean 'text:p' elements, which excludes headers but
\&        includes non-empty table cells, contents of list items and
\&        footnotes.
.Ve
.PP
.Vb 3
\&        Returned value is an element and not the text of the paragraph. All
\&        read/write operations involving attributes and content can use this
\&        element.
.Ve
.PP
\fI\fIgetParagraphList()\fI\fR
.IX Subsection "getParagraphList()"
.PP
.Vb 2
\&        Returns a list of paragraph elements (i.e. 'text:p' elements in the
\&        document body).
.Ve
.PP
\fIgetParagraphText(n)\fR
.IX Subsection "getParagraphText(n)"
.PP
.Vb 2
\&        Returns the text of the nth+1 paragraph, counted using the same
\&        rules as for getParagraph.
.Ve
.PP
\fIgetParagraphTextList([filter])\fR
.IX Subsection "getParagraphTextList([filter])"
.PP
.Vb 2
\&        Returns a list of texts contained in the paragraphs of a document
\&        ('text:p' elements).
.Ve
.PP
.Vb 3
\&        A filter can be passed as an optional argument (literal or regular
\&        expression). In this case, only paragraph texts whose content match
\&        the filter are returned.
.Ve
.PP
.Vb 4
\&        In a list context, the result is returned in the form of a list of
\&        character strings. In a scalar context, the result is a single
\&        string in which the paragraphs are separated by a line-feed
\&        character ("\en").
.Ve
.PP
\fIgetRow(table, row_num)\fR
.IX Subsection "getRow(table, row_num)"
.PP
.Vb 4
\&        Returns the element reference which corresponds to a row in a table.
\&        The first argument is either the table's sequential number in the
\&        document, logical name or element reference. The second argument is
\&        the row number in the table. Synonym: getTableRow.
.Ve
.PP
.Vb 2
\&        This methods ignores the table header (if any). It can retrieve a
\&        row in the table body only. See getTableHeaderRow().
.Ve
.PP
\fIgetRowCells(table, row)\fR
.IX Subsection "getRowCells(table, row)"
.PP
\fIgetRowCells(row)\fR
.IX Subsection "getRowCells(row)"
.PP
.Vb 3
\&        Returns the list of the uncovered cell elements corresponding to a
\&        given table row. The row can be provided either by table ID and row
\&        number or by direct row object.
.Ve
.PP
\fIgetSection(name/number)\fR
.IX Subsection "getSection(name/number)"
.PP
.Vb 3
\&        If the first argument is a number, returns the nth+1 section in a
\&        document (section numbers are zero-based; if the argument is negative,
\&        the sections are counted from the end).
.Ve
.PP
.Vb 5
\&        The second form allows you to select a section by its logical name (as
\&        it would appear to the end user when editing the section's
\&        properties). This name is obviously easier to use than a number.
\&        Moreover, this type of selection means the application will still
\&        work even if a section changes position within a document.
.Ve
.PP
.Vb 2
\&        The returned object is a "handle" that can be used for subsequent
\&        element creations or retrievals in the selected section.
.Ve
.PP
\fIgetSpanList([context])\fR
.IX Subsection "getSpanList([context])"
.PP
.Vb 6
\&        Returns a list of elements, in the given context, which correspond
\&        to texts which "stand out" from the regular flat text, i.e. which have
\&        been given a style which makes them stand out from the rest of the
\&        paragraph containing them. The context may be a paragraph, a section,
\&        or any other text container. The context argument is optional; the
\&        default context is the whole document.
.Ve
.PP
.Vb 3
\&        For example, a word in italics or in font size 12 in a paragraph of
\&        mostly standard characters in font size 10 is a 'span' element and
\&        would therefore appear in a list returned by getSpanList.
.Ve
.PP
\fIgetSpanTextList([filter])\fR
.IX Subsection "getSpanTextList([filter])"
.PP
.Vb 3
\&        Gets a list of texts which "stand out" in the same way as
\&        getSpanList and returns it under the same conditions as
\&        getParagraphTextList or getHeadingTextList, with optional filter.
.Ve
.PP
\fIgetStyle(path, position)\fR
.IX Subsection "getStyle(path, position)"
.PP
\fIgetStyle(element)\fR
.IX Subsection "getStyle(element)"
.PP
.Vb 1
\&        Obsolete. See textStyle.
.Ve
.PP
\fIgetTable(number [, length, width])\fR
.IX Subsection "getTable(number [, length, width])"
.PP
\fIgetTable(name [, length, width])\fR
.IX Subsection "getTable(name [, length, width])"
.PP
.Vb 1
\&        Returns the reference of a table, selected by name or number.
.Ve
.PP
.Vb 3
\&        If the first argument is a number, returns the nth+1 table in a
\&        document (table numbers are zero-based; if the argument is negative,
\&        the tables are counted from the end).
.Ve
.PP
.Vb 6
\&        The second form allows you to select a table by its logical name (as
\&        it would appear to the end user when editing the table's
\&        properties). This name is obviously easier to use than a number.
\&        Moreover, this type of selection means the application will still
\&        work even if a table changes position within a document. But the
\&        retrieval by name works with two restrictions:
.Ve
.PP
.Vb 2
\&        - if a table name is made of digits only, or if if represents a
\&        numeric expression, it's automatically regarded as a table number;
.Ve
.PP
.Vb 4
\&        - getTable() can't retrieve a table by name if the name contains
\&        one or more "$", "{" or "}" characters; these characters are allowed
\&        in the table names in text documents (ODT), but not allowed
\&        in spreadsheets (ODS).
.Ve
.PP
.Vb 2
\&        The returned object is a "handle" that can be used for subsequent
\&        accesses to its components (rows, cells).
.Ve
.PP
.Vb 9
\&        The additional size arguments are required with "open" tables, i.e.
\&        tables whose size is not really fixed, such as spreadsheets. If the
\&        length and width arguments are provided, the corresponding area
\&        becomes safely addressable. With OpenOffice.org Writer documents,
\&        the size declaration is presently not required, because every table
\&        has a fixed size and a continuous addressing scheme. See
\&        normalizeSheet() for details about the table size declarations. And
\&        use the size arguments each time you experience an addressing problem
\&        with a table.
.Ve
.PP
.Vb 3
\&        A getTable() call with the optional length, width arguments produces
\&        the same effect as an explicit call of normalizeSheet() with the same
\&        arguments.
.Ve
.PP
\fIgetTableColumn(table, column)\fR
.IX Subsection "getTableColumn(table, column)"
.PP
.Vb 1
\&        See getColumn.
.Ve
.PP
\fIgetTableHeaderRow(table [, row_num])\fR
.IX Subsection "getTableHeaderRow(table [, row_num])"
.PP
.Vb 2
\&        Returns the element reference which corresponds to a row in a table
\&        header, or undef if the given table has no header row.
.Ve
.PP
.Vb 4
\&        The arguments are processes in the same way as with getRow(), but
\&        the second argument is optional; it's required only if the table
\&        has more than one header row (the 1st header row is returned by
\&        default).
.Ve
.PP
.Vb 2
\&        The returned elements can be used with subsequent cell access methods
\&        in order to process header cells (see getCell()).
.Ve
.PP
\fI\fIgetTableList()\fI\fR
.IX Subsection "getTableList()"
.PP
.Vb 1
\&        Returns a list of table elements in a document.
.Ve
.PP
\fIgetTableRow(table, row)\fR
.IX Subsection "getTableRow(table, row)"
.PP
.Vb 1
\&        See getRow.
.Ve
.PP
\fIgetTableRows(table)\fR
.IX Subsection "getTableRows(table)"
.PP
.Vb 1
\&        Returns the list of the rows contained in the given table.
.Ve
.PP
.Vb 3
\&        When the user needs to process every row in large tables, this method
\&        allows some performance improvements, because it's less costly than
\&        a lot of successive getRow() calls.
.Ve
.PP
\fIgetTableSize(table)\fR
.IX Subsection "getTableSize(table)"
.PP
.Vb 3
\&        Returns the size of a table as a pair of values which represent the
\&        number of rows and columns. The table can be specified either by
\&        number, logical name or reference.
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 1
\&            my ($rows, $columns) = $doc->getTableSize("Table1");
.Ve
.PP
.Vb 13
\&        Caution: This method provides meaningful results with well delimited
\&        tables whose the XML storage is "normalized". It should not be used
\&        with "open" spreadsheets (such as OpenOffice.org Calc documents),
\&        where the physical length and width of a table don't really make
\&        sense. In the present OpenOffice.org Writer (text) documents, the
\&        tables are delimited and every row and cell is mapped to an exclusive
\&        XML element, so getTableSize() is workable (up to now) with this kind
\&        of documents. However, the OpenDocument specification allows an
\&        optimization strategy which, when implemented, prevents getTableSize()
\&        from returning workable results. In such a situation, the applications
\&        must assume the length and width of the table and, before using it,
\&        prepare a normalized addressing workspace. See normalizeSheet() for
\&        more details.
.Ve
.PP
\fIgetTableText(n)\fR
.IX Subsection "getTableText(n)"
.PP
.Vb 2
\&        Returns the content of a table, if found, whose number or reference
\&        is given as an argument. If not found, returns undef.
.Ve
.PP
.Vb 2
\&        The content of each cell is extracted according to the rules of
\&        getCellValue.
.Ve
.PP
.Vb 2
\&        In a list context, the returned value is a 2D table with each
\&        element containing the corresponding cell in the document.
.Ve
.PP
.Vb 5
\&        In a scalar context, the content is returned as a single string in
\&        CSV format. In this case, the rows are separated by a delimiter set
\&        by the instance variable 'line_separator' and the fields by the
\&        variable 'field_separator' in the OODoc::Text object. (These
\&        delimiters are by default "\en" and ";" respectively.)
.Ve
.PP
\fIgetText(path, position)\fR
.IX Subsection "getText(path, position)"
.PP
\fIgetText(element)\fR
.IX Subsection "getText(element)"
.PP
.Vb 2
\&        Exports the text contained in the given element according to the
\&        means appropriate to that type of element.
.Ve
.PP
.Vb 7
\&        If the 'use_delimiters' flag is set to 'on' (default), the content
\&        of each element (others than ordinary paragraphs, table cell,
\&        headers) is preceded and/or followed by a character string depending
\&        on the type of the element. This also depends on the settings given
\&        to the delimiter values 'begin' and 'end' by the 'delimiters' hash.
\&        In a default configuration where the application has not provided
\&        any specific delimiters, the following delimiters are used:
.Ve
.PP
.Vb 3
\&            - '<<' before and '>>' after sections of text highlighted within
\&            an element (e.g. words in bold or underlined within a paragraph
\&            of 'standard' font characters).
.Ve
.PP
.Vb 2
\&        footnote citations (in text body) are placed between square
\&        brackets.
.Ve
.PP
.Vb 1
\&        '{NOTE:' and '}' for the content of footnotes.
.Ve
.PP
.Vb 4
\&        (Footnotes are physically inserted into the text at the place
\&        where they are called, just after the link element indicating the
\&        footnote's number. Its display at the foot of the page or elsewhere
\&        is a trick of the graphical interface.)
.Ve
.PP
.Vb 6
\&        An application can change these delimiters, add more for other types
\&        of elements (e.g. paragraphs, headers, tables cells, etc.), or
\&        deactivate them using outputDelimitersOff. This depends on where the
\&        text is exported to e.g. display in editable "flat" format,
\&        conversion to non-OpenDocument XML or a markup language other than
\&        XML, generating code from text, etc..
.Ve
.PP
.Vb 3
\&        A default export (ex: "\en") terminator can be set for any element that
\&        is not listed in the 'delimiters' hash (see defaultOutputTerminator()
\&        above).
.Ve
.PP
.Vb 6
\&        If the element is an ordered or unordered list, the text produced is
\&        a concatenation of all the lines in the list, each separated by a
\&        line-break in addition to any delimiters. The default line break
\&        character is "\en", but it can be set to any other string (including
\&        an empty string) through the 'line_separator' property of the document
\&        object.
.Ve
.PP
.Vb 4
\&        If the element is a string table cell, getText behaves like
\&        getCellValue. If the cell contains more than one paragraph, the text
\&        produced is a concatenation of all the paragraph contents, each
\&        separated in the same way as list items.
.Ve
.PP
.Vb 1
\&        If the element is a table, getText behaves like getTableText.
.Ve
.PP
\fIgetTextBoxElement(name/number)\fR
.IX Subsection "getTextBoxElement(name/number)"
.PP
.Vb 2
\&        Retrieves a text box element by its unique name or by its order
\&        number in the document (or in the current context).
.Ve
.PP
\fI\fIgetTextContent()\fI\fR
.IX Subsection "getTextContent()"
.PP
.Vb 1
\&        Returns the text of a document, as "flat" editable text.
.Ve
.PP
.Vb 2
\&        In a list context, the content is returned as a table with one text
\&        element (header or paragraph) per element.
.Ve
.PP
.Vb 3
\&        In a scalar context, the content is returned as a single character
\&        string with each text unit (header or paragraph) separated by a
\&        line-feed ("\en").
.Ve
.PP
.Vb 2
\&        The returned text contains no style or level information, so there
\&        is nothing to distinguish a header from a paragraph.
.Ve
.PP
.Vb 1
\&        Same as selectTextContent('.*').
.Ve
.PP
\fI\fIgetTextElementList()\fI\fR
.IX Subsection "getTextElementList()"
.PP
.Vb 2
\&        Returns the list of all the text elements, including headers,
\&        paragraphs and item lists.
.Ve
.PP
\fIgetTopParagraph(n)\fR
.IX Subsection "getTopParagraph(n)"
.PP
.Vb 2
\&        Same as getParagraph but only considers top level paragraphs. The
\&        contents of lists, tables and footnotes are excluded.
.Ve
.PP
\fIgetUnorderedList(n)\fR
.IX Subsection "getUnorderedList(n)"
.PP
.Vb 2
\&        Returns the element which represents the nth+1 unordered list in a
\&        document, if found.
.Ve
.PP
.Vb 2
\&        WARNING: Ordered lists are possible in the OpenOffice.org 1 format
\&        only. Don't use it against OpenDocument.
.Ve
.PP
\fIgetUserFieldElement(name)\fR
.IX Subsection "getUserFieldElement(name)"
.PP
.Vb 2
\&        Returns the element (if defined) representing a user-defined field,
\&        and corresponding to the given name. See also userFieldValue().
.Ve
.PP
\fIgetVariableElement(name)\fR
.IX Subsection "getVariableElement(name)"
.PP
.Vb 1
\&        Returns the user-defined variable identified by the given name.
.Ve
.PP
.Vb 1
\&        [Contribution by Andrew Layton]
.Ve
.PP
\fIhyperlinkURL(hyperlink [, url])\fR
.IX Subsection "hyperlinkURL(hyperlink [, url])"
.PP
.Vb 4
\&        Get/set the URL of an hyperlink element. The first argument may be
\&        a previously retrieved hyperlink element (see selectHyperlinkElement
\&        below), or the URL of an existing hyperlink. If a second argument is
\&        provided, it replaces the URL of the hyperlink element.
.Ve
.PP
.Vb 3
\&        With only one argument, just returns the existing URL of the link,
\&        or undef if the first argument doesn't match an existing hyperlink
\&        element.
.Ve
.PP
\fIinputTextConversion(text)\fR
.IX Subsection "inputTextConversion(text)"
.PP
.Vb 3
\&        Returns the UTF8 conversion of the given text, supposed to be in
\&        the local character set of the document (see the 'local_encoding'
\&        property).
.Ve
.PP
\fIinsertColumn(table, col_num [, options])\fR
.IX Subsection "insertColumn(table, col_num [, options])"
.PP
.Vb 1
\&        Inserts a new column in an existing table at a given position.
.Ve
.PP
.Vb 3
\&        The second argument must be the number of an existing column.
\&        Caution: this argument must be a column number, and not a column
\&        element.
.Ve
.PP
.Vb 3
\&        The new column is created as a copy of the column a the given
\&        position. It's inserted before or after the existing one, according
\&        to an optional "position" parameter (default 'before').
.Ve
.PP
.Vb 5
\&        Caution: before using insertColumn() against a spreadsheet, the
\&        application should ensure that the whole rectangular area from the top
\&        left cell ("A1") to the last used cell of the column at the target
\&        position is "normalized" (see normalizeSheet() for details about the
\&        table normalization).
.Ve
.PP
\fIinsertDrawPage(page/pos [, options])\fR
.IX Subsection "insertDrawPage(page/pos [, options])"
.PP
.Vb 2
\&        In a presentation or drawing document, inserts a new page before
\&        or after an existing page.
.Ve
.PP
.Vb 2
\&        Possible options are the same as for appendDrawPage(), with an
\&        additional one:
.Ve
.PP
.Vb 1
\&                position        => 'before' or 'after' (default 'before')
.Ve
.PP
.Vb 2
\&        The new page is inserted before or after the reference page, according
\&        to the 'position' option.
.Ve
.PP
.Vb 4
\&        The first argument can be a draw page element reference (recommended)
\&        previously returned, for example, by a previous page retrieval or
\&        creation method call. Alternatively, it can be a page position or
\&        visible name, so it's regarded in the same way as in getDrawPage().
.Ve
.PP
.Vb 1
\&        Returns the new page element, or undef in case of failure.
.Ve
.PP
\fIinsertHeading(path, position, options)\fR
.IX Subsection "insertHeading(path, position, options)"
.PP
\fIinsertHeading(element, options)\fR
.IX Subsection "insertHeading(element, options)"
.PP
.Vb 2
\&        Same as appendHeading, but inserts the new heading before or after
\&        another element.
.Ve
.PP
.Vb 3
\&        Position is that of an existing element which can be another heading
\&        or a paragraph. Can be given by [path, position] or by element
\&        reference.
.Ve
.PP
.Vb 5
\&        Possible options are the same as for appendHeading, with the
\&        additional option 'position' which determines if the heading is
\&        inserted before or after the element at the given position. Possible
\&        values for this option are 'before' and 'after'. By default, the new
\&        element is inserted before the given element.
.Ve
.PP
\fIinsertItemList(path, position [, options])\fR
.IX Subsection "insertItemList(path, position [, options])"
.PP
\fIinsertItemList(element [, options])\fR
.IX Subsection "insertItemList(element [, options])"
.PP
.Vb 4
\&        Same as appendItemList, but a new list is inserted at the given
\&        position. The point of insertion can be given either by the pair
\&        [path, position] or by element reference. Options are the same as
\&        for insertParagraph.
.Ve
.PP
\fIinsertParagraph(path, position [, options])\fR
.IX Subsection "insertParagraph(path, position [, options])"
.PP
\fIinsertParagraph(element [, options])\fR
.IX Subsection "insertParagraph(element [, options])"
.PP
.Vb 2
\&        Same as appendParagraph, but a new paragraph is inserted at the
\&        given position.
.Ve
.PP
.Vb 3
\&        Position is that of an existing element which can be another
\&        paragraph or a header. Can be given by [path, position] or by
\&        element reference.
.Ve
.PP
.Vb 5
\&        Options are the same as for appendParagraph, with the additional
\&        option 'position' which determines whether the paragraph is inserted
\&        before or after the element at the given position. Possible values
\&        for this options are 'before' and 'after'. By default, the element
\&        is inserted before the given element.
.Ve
.PP
\fIinsertRow(table, row [, options])\fR
.IX Subsection "insertRow(table, row [, options])"
.PP
\fIinsertRow(row_element [, options])\fR
.IX Subsection "insertRow(row_element [, options])"
.PP
.Vb 5
\&        Inserts a new row into a table. In its first form, pass the table
\&        (reference, logical name or number) and the position number in the
\&        table. In its second form, pass the element reference of the
\&        existing row which is directly before or after the position where
\&        you want to make the insertion.
.Ve
.PP
.Vb 6
\&        By default, the new row is inserted at the position of the
\&        referenced row, which displaces it and the rest of the table down by
\&        one row position. However, you can insert it after by using the
\&        'position => after' option. By default, the new row is an exact copy
\&        of the referenced row, but you can assign particular attributes to
\&        it in the same manner as the insertElement method of OODoc::XPath.
.Ve
.PP
\fIinsertSection(path, position, name [, options])\fR
.IX Subsection "insertSection(path, position, name [, options])"
.PP
\fIinsertSection(element, name [, options])\fR
.IX Subsection "insertSection(element, name [, options])"
.PP
.Vb 3
\&        Creates a new section and inserts it immediately before or after
\&        an existing element (paragraph, header, table). The referenced element
\&        can be indicated as in insertParagraph.
.Ve
.PP
.Vb 2
\&        There is a "position" option which works in the same way as with
\&        insertParagraph() or insertRow().
.Ve
.PP
.Vb 2
\&        For other options, see appendSection(). For example, insertSection()
\&        may be used in order to insert a subdocument in a master document.
.Ve
.PP
\fIinsertString(path, position, text, offset)\fR
.IX Subsection "insertString(path, position, text, offset)"
.PP
\fIinsertString(element, text, offset)\fR
.IX Subsection "insertString(element, text, offset)"
.PP
.Vb 4
\&        Inserts a flat character string in a given element (whatever the type
\&        of element) at the given offset. If the offset is not defined, the
\&        text is appended to the end of the element (however, if the offset is
\&        provided and set to zero, the string is inserted at the beginning).
.Ve
.PP
\fIinsertTable(path, position, name, rows, columns [, options])\fR
.IX Subsection "insertTable(path, position, name, rows, columns [, options])"
.PP
\fIinsertTable(element, name, rows, columns [, options])\fR
.IX Subsection "insertTable(element, name, rows, columns [, options])"
.PP
.Vb 5
\&        Creates a new table and inserts it immediately before or after
\&        another element (paragraph, header, table). The referenced element
\&        can be indicated as in insertParagraph. The other arguments and
\&        options are the same as for appendTable with the additional option
\&        'position' as in insertParagraph.
.Ve
.PP
\fIinsertTableColumn(table, col_num [, options])\fR
.IX Subsection "insertTableColumn(table, col_num [, options])"
.PP
.Vb 1
\&        See insertColumn().
.Ve
.PP
\fIinsertTableRow(table, row [, options])\fR
.IX Subsection "insertTableRow(table, row [, options])"
.PP
\fIinsertTableRow(row_element [, options])\fR
.IX Subsection "insertTableRow(row_element [, options])"
.PP
.Vb 1
\&        See insertRow().
.Ve
.PP
\fIlockSection(section [, key])\fR
.IX Subsection "lockSection(section [, key])"
.PP
.Vb 1
\&        Installs a write protection on the given section.
.Ve
.PP
.Vb 3
\&        If a second argument is provided, it's stored as an encrypted key
\&        which is associated to the write protection. Caution, it's not the
\&        key as it should be typed by the OOo end-user.
.Ve
.PP
.Vb 4
\&        Such a write protection works only when the document is edited through
\&        an OpenOffice.org-compatible desktop software. It doesn't prevent the
\&        programs using OpenOffice::OODoc from deleting or updating the
\&        protected sections.
.Ve
.PP
\fImakeHeading([options])\fR
.IX Subsection "makeHeading([options])"
.PP
.Vb 2
\&        Creates a new heading element, or marks as a heading an existing
\&        element.
.Ve
.PP
.Vb 1
\&        Options:
.Ve
.PP
.Vb 1
\&                element         => an arbitrary existing element
.Ve
.PP
.Vb 3
\&        If this option is provided, the given element is converted in place
\&        to a heading, whatever its original type and position. No element
\&        is created.
.Ve
.PP
.Vb 4
\&        Without the 'element' option, a new heading element is created and
\&        returned for later use. This element is free; it's not automatically
\&        attached somewhere in the document. For direct heading creation and
\&        attachment, you should prefer appendHeading() or insertHeading().
.Ve
.PP
.Vb 1
\&                level           => a numeric, positive integer value
.Ve
.PP
.Vb 2
\&        Sets the hierarchical level of the heading (remember 1 is the top
\&        heading level). Caution: no default value.
.Ve
.PP
.Vb 1
\&                style           => the name of a convenient heading style
.Ve
.PP
.Vb 5
\&        While it's not mandatory, the 'style' option and a properly defined
\&        heading style are generally required in order to allow the office
\&        software to really process and display the element as a heading with
\&        the right hierarchical level. Of course, any previously existing
\&        hierarchical style is reusable here.
.Ve
.PP
.Vb 4
\&        The main purpose of this method is to allow quick heading hierarchy
\&        creation in a "flat" document. For exemple, an application can select
\&        a set of flat paragraphs matching a given condition and convert each
\&        one in place to a heading with a given level.
.Ve
.PP
\fImoveElementsToSection(section, list)\fR
.IX Subsection "moveElementsToSection(section, list)"
.PP
.Vb 1
\&        Moves a list of elements from any place to a section.
.Ve
.PP
.Vb 2
\&        The section may be passed by name or by element reference; it must be
\&        an existing one (no new section is created).
.Ve
.PP
.Vb 3
\&        The list is a set of arbitrary elements (including sections). Each one
\&        is cut from its previous place and appended to the section in the
\&        order of the list, without document consistency check.
.Ve
.PP
\fInormalizeSheet(sheet, rows, columns)\fR
.IX Subsection "normalizeSheet(sheet, rows, columns)"
.PP
.Vb 9
\&        This method preprocesses a given sheet so its components (rows,
\&        cells) become available for all the table-oriented methods described
\&        in this chapter. The 2nd and 3rd arguments control the size of a
\&        rectangular area, beginning at the first cell ([0, 0] or "A1"), to
\&        be processed. The processed area becomes a workspace which is safely
\&        addressable by any cell/row/column processing method. This
\&        preprocessing is sometimes required, sometimes not. Simply speaking,
\&        it's required on present OpenOffice.org Calc spreadsheets, and
\&        useless on present OpenOffice.org Text tables.
.Ve
.PP
.Vb 3
\&        It's automatically executed when getTable() is called
\&        with size arguments; therefore it's not always explicitly invoked by
\&        the applications. However, it's useful to know its purpose.
.Ve
.PP
.Vb 15
\&        The object addressing logic (which, for example, allows a program to
\&        directly reach a cell using its coordinates) relies on a continuous,
\&        regular mapping between the user's view and the physical XML storage
\&        of the tables. However, the OpenDocument specification allows any
\&        conforming application to map more than one table element to a
\&        single XML element. When two or more contiguous objects contain
\&        the same value and have the same style and the same data type, they
\&        *may* be mapped to a single XML element with a repetition attribute.
\&        As a consequence, the position of the appropriate XML element can't be
\&        directly calculated from the logical coordinates of the object, and
\&        OODoc needs to scan the table in order to get all the repetition
\&        attributes and calculate the real mapping. In addition, updating an
\&        object whose the XML corresponding element has a repetition attribute
\&        would automatically update all the objects mapped to the same element,
\&        producing unpredictable and generally wrong results.
.Ve
.PP
.Vb 6
\&        OpenOffice.org Calc systematically uses this storage optimization in
\&        spreadsheets, while OpenOffice.org Writer doesn't use it for tables in
\&        text documents. In Calc (sxc/ods) documents, the XML mapping of the
\&        whole content is "denormalized" in order to save memory: several table
\&        components can be mapped to a single XML element, so the XML address
\&        of each one can't be simply calculated from its logical coordinates.
.Ve
.PP
.Vb 3
\&        In order to allow the spreadsheet components to be addressed with the
\&        same methods as the Writer table components, normalizeSheet()
\&        reorganizes the XML mapping of the given sheet.
.Ve
.PP
.Vb 6
\&        Caution: The OpenDocument specification doesn't make any difference
\&        about this point between tables included in text documents and tables
\&        in spreadsheet-only documents. So any ODF-compliant application
\&        *could* denormalize the XML storage of any table and use the
\&        repetition attributes. As a consequence, normalizeSheet() *could* be
\&        required in the future for other documents than OOo Calc ones.
.Ve
.PP
.Vb 7
\&        This method is not (presently) always needed for tables included
\&        in OpenOffice.org Writer (odt/sxw) documents, because their storage is
\&        "normalized" (i.e. each component is mapped to an exclusive XML
\&        element), with the exception of the column objects. So,
\&        normalizeSheet() is required with these tables when the application
\&        needs to use a column-focused method such as getColumn(),
\&        insertColumn() or deleteColumn().
.Ve
.PP
.Vb 5
\&        In the other hand, normalizeSheet() is not required to address a sheet
\&        which has been created through the OODoc methods (provided that the
\&        document has not been edited with OpenOffice.org in the meantime).
\&        These methods, i.e. appendTable() and insertTable(), create normalized
\&        tables, whatever the document class.
.Ve
.PP
.Vb 9
\&        Because this method is very time and memory consuming, it should never
\&        be used to reorganize the largest possible area of a sheet (meaning
\&        thousands of rows and hundreds of columns that will probably never be
\&        used). So it's action is limited to a given area, controlled by the
\&        rows, columns arguments. When these arguments are not provided, the
\&        method uses the 'max_rows' and 'max_cols' properties instead (see the
\&        Properties section for other explanations). The processed area should
\&        be sized in order to cover all the cells to be reached by the program,
\&        and nothing more.
.Ve
.PP
.Vb 4
\&        The first argument can be either the logical name of the sheet (as
\&        it's shown in the bottom tab by OOo Calc), the sheet number, or a
\&        table object reference, previously returned by getTable(). The return
\&        value is the table object (or undef in case of failure).
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 3
\&                $doc = ooDocument(file => 'report.sxc');
\&                my $sheet = $doc->normalizeSheet('Sheet1', 7, 9);
\&                my $result = $doc->cellValue($sheet, 5, 6);
.Ve
.PP
.Vb 4
\&        In the sequence above, a top left area of 7 rows by 8 columns is
\&        pre-processed, so the cells from A1 to H6 of this sheet can be
\&        reached according to the same addressing scheme as in Writer tables.
\&        The last instruction gets the content of G6.
.Ve
.PP
.Vb 5
\&        The transformed sheets, of course, are readable by OOo Calc.
\&        They simply take some more disk space when the processed spreadsheet
\&        is saved. If the document is later read then written by OOo Calc,
\&        the storage is optimized again, so the effects of normalizeSheet()
\&        disappear.
.Ve
.PP
.Vb 6
\&        normalizeSheet() can be used safely against Writer document tables,
\&        with two possible results. If the table size is greater than the given
\&        size, the method is neutral. Otherwise, the length and/or the width is
\&        increased according to the given arguments (however, the new rows and
\&        columns appear with default styles, so the extended table may be badly
\&        presented).
.Ve
.PP
.Vb 2
\&        An explicit call to this method can be replaced by getTable() with the
\&        additional length and width parameters.
.Ve
.PP
\fInormalizeTable(table [, rows [, columns]])\fR
.IX Subsection "normalizeTable(table [, rows [, columns]])"
.PP
.Vb 1
\&        See normalizeSheet().
.Ve
.PP
\fI\fIoutputDelimitersOn()\fI\fR
.IX Subsection "outputDelimitersOn()"
.PP
\fI\fIoutputDelimitersOff()\fI\fR
.IX Subsection "outputDelimitersOff()"
.PP
.Vb 2
\&        Turns delimiters on or off. Used to mark up text exported by certain
\&        methods like getText or selectTextContent.
.Ve
.PP
.Vb 2
\&        The delimiters actually used depends on the table loaded into the
\&        OODoc::Text instance via the 'delimiters' property.
.Ve
.PP
\fIoutputTextConversion(text)\fR
.IX Subsection "outputTextConversion(text)"
.PP
.Vb 3
\&        Returns the conversion in local character set of the given text,
\&        supposed to be in UTF8. The local character set of the document
\&        is used (see the 'local_encoding' property).
.Ve
.PP
\fIremoveBookmark(id)\fR
.IX Subsection "removeBookmark(id)"
.PP
.Vb 1
\&        See deleteBookmark().
.Ve
.PP
\fIremoveHeading(position [, level => level_no])\fR
.IX Subsection "removeHeading(position [, level => level_no])"
.PP
\fIremoveHeading(element)\fR
.IX Subsection "removeHeading(element)"
.PP
.Vb 1
\&        Removes the given heading element.
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 1
\&            $doc->removeHeading(4);
.Ve
.PP
.Vb 2
\&        removes the 5th heading (whatever its level) counted from the
\&        beginning of the document.
.Ve
.PP
.Vb 1
\&        See getHeading() for the argument and option.
.Ve
.PP
.Vb 3
\&        If the argument is an element reference (second form), the type is
\&        not checked and this method becomes the equivalent of removeElement()
\&        (which is documented with OpenOffice::OODoc::XPath generic methods).
.Ve
.PP
\fIremoveHyperlink(path, position)\fR
.IX Subsection "removeHyperlink(path, position)"
.PP
\fIremoveHyperlink(element)\fR
.IX Subsection "removeHyperlink(element)"
.PP
.Vb 2
\&        Removes any hyperlink contained in the given element, leaving
\&        in place the previously hyperlinked text.
.Ve
.PP
\fIremoveParagraph(position)\fR
.IX Subsection "removeParagraph(position)"
.PP
\fIremoveParagraph(element)\fR
.IX Subsection "removeParagraph(element)"
.PP
.Vb 1
\&        Removes the paragraph at the given position (first form).
.Ve
.PP
.Vb 3
\&        The paragraph to be removed can be indicated by element reference
\&        (second form). In this case, the type of element is not checked and
\&        this method becomes the equivalent of removeElement.
.Ve
.PP
\fIremoveCellSpan($cell)\fR
.IX Subsection "removeCellSpan($cell)"
.PP
.Vb 3
\&        Removes the multi-column, multi-row span of a table cell. The width
\&        and height of the cell are reduced to one column and one row.The
\&        uncovered cells take the same style and data type as the reduced cell.
.Ve
.PP
.Vb 7
\&        Caution: This method works with cells that heve been expanded using
\&        the "number-rows-spanned" and "number-columns-spanned" OpenDocument
\&        attributes. The cell expansion is done this way by the cellSpan()
\&        method, as well as with the present version of OpenOffice.org Calc.
\&        But other applications (including the present version of
\&        OpenOffice.org Writer) can implement the cell merge using subtables
\&        instead of span attributes.
.Ve
.PP
\fIremoveSpan(path, position)\fR
.IX Subsection "removeSpan(path, position)"
.PP
\fIremoveSpan(element)\fR
.IX Subsection "removeSpan(element)"
.PP
.Vb 2
\&        "Flattens" a text element, removing all presentation distinctions
\&        which may mark out some substrings of its content.
.Ve
.PP
.Vb 1
\&        For a more drastic result, see flatten() in OpenOffice::OODoc::XPath.
.Ve
.PP
.Vb 1
\&        See also setSpan().
.Ve
.PP
\fIrenameSection(section, newname)\fR
.IX Subsection "renameSection(section, newname)"
.PP
.Vb 1
\&        Renames an existing section using the second argument.
.Ve
.PP
\fIrenameTable(table, newname)\fR
.IX Subsection "renameTable(table, newname)"
.PP
.Vb 1
\&        Renames an existing table using the second argument.
.Ve
.PP
\fIrowStyle(row_element [, style])\fR
.IX Subsection "rowStyle(row_element [, style])"
.PP
\fIrowStyle(table, row [, style])\fR
.IX Subsection "rowStyle(table, row [, style])"
.PP
.Vb 2
\&        Reads or modifies a table row's style, in the same way as
\&        columnStyle does for columns.
.Ve
.PP
\fIsectionProtectionKey(section)\fR
.IX Subsection "sectionProtectionKey(section)"
.PP
.Vb 2
\&        Returns the encrypted key which is associated to the given section,
\&        if the section is write-protected by key.
.Ve
.PP
.Vb 4
\&        This method can't provide the real key (as it should be typed by
\&        the end-user to unlock the section), but the returned value may be
\&        reused in order to protect more than one section with the same
\&        password.
.Ve
.PP
.Vb 1
\&        See also unlockSection().
.Ve
.PP
\fIsectionStyle(section, [newstylename])\fR
.IX Subsection "sectionStyle(section, [newstylename])"
.PP
.Vb 1
\&        Without argument, returns the current style of a given section.
.Ve
.PP
.Vb 1
\&        If an argument is provided, it becomes the new style of the section.
.Ve
.PP
\fIselectDrawPageByName(name)\fR
.IX Subsection "selectDrawPageByName(name)"
.PP
.Vb 2
\&        In a presentation or drawing document, returns the page element
\&        identified by the given name, or undef if the name is unknown.
.Ve
.PP
.Vb 2
\&        The names to be used correspond to the displayed page names in
\&        OpenOffice.org Impress.
.Ve
.PP
\fIselectElementByBookmark(name)\fR
.IX Subsection "selectElementByBookmark(name)"
.PP
.Vb 1
\&        Returns the element containing the given bookmark.
.Ve
.PP
.Vb 3
\&        Caution: this method works with position bookmarks only, not with
\&        range bookmarks (a range bookmark can be spread over several text
\&        elements).
.Ve
.PP
\fIselectElementByContent(filter, [...])\fR
.IX Subsection "selectElementByContent(filter, [...])"
.PP
.Vb 3
\&        Returns the first text element whose content matches the 'filter'
\&        (which can be an exact string or a regular expression), or undef
\&        if no matching content is found.
.Ve
.PP
.Vb 3
\&        With more than one argument, this method can be used for replacement
\&        operations, or user-defined function triggering, in the same
\&        conditions as selectElementsByContent().
.Ve
.PP
\fIselectElementsByContent(filter)\fR
.IX Subsection "selectElementsByContent(filter)"
.PP
\fIselectElementsByContent(filter, replacement)\fR
.IX Subsection "selectElementsByContent(filter, replacement)"
.PP
\fIselectElementsByContent(filter, action [, other_arguments])\fR
.IX Subsection "selectElementsByContent(filter, action [, other_arguments])"
.PP
.Vb 4
\&        This method returns a list of text elements such as paragraphs,
\&        headers or ordered/unordered lists whose content matches the search
\&        criteria contained in 'filter' (which can be an exact string or a
\&        regular expression).
.Ve
.PP
.Vb 15
\&        This method is context-sensitive (see currentContext() and
\&        resetCurrentContext() in OpenOffice::OODoc::XPath for details about
\&        the context). Its search space is restrained to the children of the
\&        context element (so the default search space is the whole document
\&        body). Be careful: if the search is successful, the returned elements
\&        are not always the direct containers of the string which matches the
\&        filter; they are the elements whose any child element contains the
\&        string. For example, if a table cell contains a matching string, the
\&        containing table, and not the cell, is returned. If a paragraph
\&        containing the matching string belongs to a section, the section,
\&        not the paragraph, is returned. However, if the current context is
\&        the table, selectElementsByContent() will return the matching rows.
\&        And if the context is the section, it will return the matching
\&        objects included in the section (knowing that a section can contain
\&        other sections and any other structured containers).
.Ve
.PP
.Vb 2
\&        The first form simply returns the given list without modifying the
\&        text.
.Ve
.PP
.Vb 3
\&        The second form returns the same list, but replaces all strings
\&        which match the search criteria with the 'replacement' string as it
\&        goes.
.Ve
.PP
.Vb 7
\&        The third form, where the 'action' argument is a program function
\&        reference, launches the given function each time the filter string
\&        is matched. If defined, the value returned by the function is used
\&        as the replacement value. If the function returns a null value
\&        (undef) then no replacement is made. If it returns an empty string,
\&        the retrieved text is deleted. The called function receives the rest
\&        of the arguments, in this order:
.Ve
.PP
.Vb 1
\&        1) all remaining arguments after 'action' ('other_arguments'), if any.
.Ve
.PP
.Vb 1
\&        2) the element containing the retrieved text.
.Ve
.PP
.Vb 3
\&        3) the string actually selected. If the filter is an exact string,
\&        it is equal to the filter. If the filter is a regular expression,
\&        it matches the "real" text retrieved.
.Ve
.PP
.Vb 1
\&        The returned text (if any) must be encoded in UTF8.
.Ve
.PP
.Vb 1
\&        The returned list is the same one returned by the first two forms.
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 15
\&            sub action
\&                {
\&                my ($d, $element, $value) = @_;
\&                if ($value < 100)
\&                        {
\&                        $d->removeElement($element);
\&                        return undef;
\&                        }
\&                else
\&                        {
\&                        return $value * 2;
\&                        }
\&                }
\&                        @list =
\&             $doc->selectElementsByContent("[0-9]+", \e&action, $doc);
.Ve
.PP
.Vb 14
\&        In the above code, the subroutine "action" is called each time an
\&        integer (one or more digits) is found. The subroutine receives the
\&        document reference itself as its first argument (an OODoc::Text
\&        object given by the application). Next, it automatically receives
\&        the reference of the element in which the search string was found
\&        (i.e. an integer) and, finally, it receives the exact number found
\&        as its second-last and last arguments respectively. If this number
\&        is less than 100, the element is removed. This is why the subroutine
\&        needed the $doc object, used to invoke the removeElement method. If
\&        more than 100, the number is multiplied by two and the result
\&        replaces the original value in the element. The list returned by
\&        selectElementsByContent contains all elements which contain the
\&        search string, including any which might have been removed by the
\&        called function while it was running.
.Ve
.PP
.Vb 7
\&        It is the "main" elements containing strings which matched the
\&        filter which are returned and not any of their sub-elements. For
\&        example, if the returned string is found in one of the items in an
\&        unordered list, the list element is selected and not the item.
\&        Similarly, the table is selected when one of its cells matches the
\&        filter, and the paragraph which is selected when the search string
\&        is found in an attached footnote.
.Ve
.PP
.Vb 7
\&        However, a character string cannot be considered to match the filter
\&        unless it is entirely within the same sub-element and all its
\&        characters have the same style. For example, if you were searching
\&        for the string "OpenOffice" using selectElementsByContent, the
\&        string, if present, can't be found if, say, "Open" and "Office" are
\&        not represented with the same font, the same color and/or the same
\&        font size.
.Ve
.PP
.Vb 3
\&        Note: This method can be used with a "non-filtering" regular
\&        expression (".*") for unconditional movement through all text
\&        elements.
.Ve
.PP
\fIselectElementByTextId(id)\fR
.IX Subsection "selectElementByTextId(id)"
.PP
.Vb 5
\&        Returns the element (if any) identified by the given value of text
\&        identifier. The text identifier (i.e. "text:id") is an optional
\&        attribute for text containers. It *should* be unique in a document.
\&        However, this identifier is presently used in a few elements only
\&        by OpenOffice.org.
.Ve
.PP
\fIselectHyperlinkElement(url_filter)\fR
.IX Subsection "selectHyperlinkElement(url_filter)"
.PP
.Vb 2
\&        Retrieves the first hyperlink element (if any) whose the URL matches
\&        the argument. Example:
.Ve
.PP
.Vb 1
\&                my $e = $doc->selectHyperlinkElement("cpan");
.Ve
.PP
.Vb 3
\&        could return an hyperlink element containing "www.cpan.org" as
\&        well as "search.cpan.org", etc. The URL filter is processed as
\&        a regexp.
.Ve
.PP
.Vb 3
\&        Note: In order to get the text container (ex: paragraph) where the
\&        hyperlink is located, the application can use the parent() element
\&        method. Example:
.Ve
.PP
.Vb 2
\&                 my $e = $doc->selectHyperlinkElement("www.cpan.org");
\&                 my $p = $e->parent if $e;
.Ve
.PP
\fIselectHyperlinkElements(url_filter)\fR
.IX Subsection "selectHyperlinkElements(url_filter)"
.PP
.Vb 2
\&        Returns the list of the hyperlink elements whose the URL matches
\&        the argument (and not only the first one).
.Ve
.PP
\fIselectParagraphByStyle(stylename)\fR
.IX Subsection "selectParagraphByStyle(stylename)"
.PP
.Vb 1
\&        Returns the first paragraph (if any) using the given style.
.Ve
.PP
\fIselectParagraphsByStyle(stylename)\fR
.IX Subsection "selectParagraphsByStyle(stylename)"
.PP
.Vb 1
\&        Returns the list of the paragraphs using the given style.
.Ve
.PP
\fIselectTextContent(filter)\fR
.IX Subsection "selectTextContent(filter)"
.PP
\fIselectTextContent(filter, replacement)\fR
.IX Subsection "selectTextContent(filter, replacement)"
.PP
\fIselectTextContent(filter, action [, other_arguments])\fR
.IX Subsection "selectTextContent(filter, action [, other_arguments])"
.PP
.Vb 2
\&        Returns a list of header texts and/or paragraphs (in the document's
\&        own order) which match the given search criteria.
.Ve
.PP
.Vb 3
\&        The filter can be an exact string or a regular expression. A filter
\&        set to ".*" (no selection) will result in an export of the entire
\&        text.
.Ve
.PP
.Vb 3
\&        In all three forms, this method behaves like
\&        selectElementsByContent, except that it returns text instead of a
\&        list of elements.
.Ve
.PP
.Vb 3
\&        Depending on the context (list or scalar), the result is returned in
\&        the form of a list of rows or in the form of a single character
\&        string where the elements are separated by a line-feed ("\en").
.Ve
.PP
.Vb 2
\&        Note: called with a "non-filtering" regular expression, this method
\&        will result in a "flat" export of the document:
.Ve
.PP
.Vb 1
\&            print $doc->selectTextContent('.*');
.Ve
.PP
\fIsetBibliographyMark(element, offset, identifier => id [, options])\fR
.IX Subsection "setBibliographyMark(element, offset, identifier => id [, options])"
.PP
.Vb 6
\&        Creates a new bibliography mark within a given text element at a
\&        given offset. The hosting element, the offset (relative to the content
\&        of the element) and the "identifier" parameter are mandatory. The other
\&        options are all the possible attributes of an OpenDocument-compliant
\&        bibliography entry, such as author, editor, isbn, title, year, and
\&        many others. Example:
.Ve
.PP
.Vb 10
\&                $para = $doc->selectElementByContent("ODF-related book");
\&                $doc->setBibliographyMark
\&                        (
\&                        $para, 0,
\&                        identifier      => "JDE",
\&                        title           => "OASIS OpenDocument Essentials",
\&                        author          => "J. David Eisenberg",
\&                        year            => 2005,
\&                        isbn            => "1-4116-6832-4"
\&                        );
.Ve
.PP
.Vb 3
\&        This sequences puts a bibliography mark at the beginning (position=0)
\&        of a previously selected text element. This mark will be displayed by
\&        default as "[JDE]" with OpenOffice.org Writer.
.Ve
.PP
\fIsetBookmark(element, name [, offset])\fR
.IX Subsection "setBookmark(element, name [, offset])"
.PP
.Vb 1
\&        Puts a bookmark in a text element.
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 3
\&                my $paragraph = $doc->selectElementByContent
\&                                                ("Eragon and Saphira");
\&                $doc->setBookmark($paragraph, "The Heroes");
.Ve
.PP
.Vb 3
\&        puts a bookmark identified by "The Heroes" in a paragraph where a
\&        given text has been found (of course, the bookmark will remain even
\&        if the text of the paragraph is changed later).
.Ve
.PP
.Vb 3
\&        By default, the bookmark is put at the beginning of the text. But,
\&        thanks to the optional offset, it can be put at any position within
\&        the text of the bookmarked element.
.Ve
.PP
.Vb 4
\&        Note: This method puts a position bookmark, and not a range bookmark.
\&        The OpenDocument specification allows both range and position
\&        bookmarks. However, a range bookmark is not an element; it's a pair
\&        of elements ("bookmark-start" and "bookmark-end").
.Ve
.PP
\fIsetHyperlink(path, position, [context,] expression, url)\fR
.IX Subsection "setHyperlink(path, position, [context,] expression, url)"
.PP
\fIsetHyperlink(element, [context,] expression, url [, options])\fR
.IX Subsection "setHyperlink(element, [context,] expression, url [, options])"
.PP
.Vb 1
\&        Puts an hyperlink on a text area in a given text element.
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 1
\&            $doc->setHyperlink($para, "CPAN", "http://www.cpan.org");
.Ve
.PP
.Vb 4
\&        This method works in the same was as setSpan(), described below,
\&        but the text span is hyperlinked, and not only presented according
\&        a particular style. So, the third argument must be an URL instead
\&        of a style.
.Ve
.PP
.Vb 3
\&        A set of hyperlink attributes may be optionally provided as a hash.
\&        For example, the application can provide a 'style-name' and a
\&        'visited-style-name' options:
.Ve
.PP
.Vb 6
\&            $doc->setHyperlink
\&                        (
\&                        $para, "CPAN", "http://www.cpan.org",
\&                        'style-name' => "ToBeVisited",
\&                        'visited-style-name' => "Visited"
\&                        );
.Ve
.PP
.Vb 5
\&        'style-name' selects the style which applies to the text of the
\&        hyperlink, as long as the URL is not visited, while
\&        'visited-style-name' indicates, of course, the style in use if the
\&        link location was already visited. These styles must belong to the
\&        'text' family.
.Ve
.PP
.Vb 2
\&        Other allowed hyperlink attributes are listed in the 5.1.4 of the
\&        OASIS OpenDocument 1.0 specification.
.Ve
.PP
.Vb 7
\&        Note: The hyperlink is not always a remote URL, such as in the
\&        example above. Internal references ere allowed as well. An
\&        internal reference is prefixed by "#". If an internal reference
\&        is a heading, it's prefixed by "#" and suffixed by "|outline".
\&        An hyperlink may be aimed at a location inside another document;
\&        such a link is the concatenation of a file path, a "#", and a local
\&        name that makes sense in the target document (bookmark, heading...).
.Ve
.PP
\fIsetSpan(path, position, [context,] expression, style)\fR
.IX Subsection "setSpan(path, position, [context,] expression, style)"
.PP
\fIsetSpan(element, [context,] expression, style)\fR
.IX Subsection "setSpan(element, [context,] expression, style)"
.PP
.Vb 2
\&        Applies a special text style to one or more parts of the content
\&        of a text element.
.Ve
.PP
.Vb 4
\&        In OpenDocument XML language, a "text span" is a substring whose
\&        presentation style differs from the style of the text element to
\&        which it belongs. For example, a given "span" could be in italics
\&        while the rest of the paragraph is in normal characters.
.Ve
.PP
.Vb 2
\&        Caution: the same word has a different meaning when it's used
\&        about table cells (see cellSpan()).
.Ve
.PP
.Vb 3
\&        A "span" is therefore a way to use several styles within the same
\&        element, bearing in mind that the paragraph's global style can be
\&        modified by setStyle().
.Ve
.PP
.Vb 4
\&        The properties of a text span can be related to any kind of character
\&        string presentation, such as font, font size, font weight, font
\&        style, and colors (background and foreground). Whatever these
\&        properties, they apply through a style.
.Ve
.PP
.Vb 5
\&        The desired text element is normally indicated by [path, position]
\&        or reference (recommended). The optional argument 'context' which
\&        consists of an element reference, allows you (when using [path,
\&        position]) to limit a search to child elements of a particular
\&        element (e.g. page header, page footer, item list, section, etc.).
.Ve
.PP
.Vb 4
\&        'expression' represents a filter; every substring contained
\&        in the target element and matching the filter is attributed using the
\&        given style. This filter is processed, up to some extent, as a regular
\&        expression, but there is no full perl regexp support here.
.Ve
.PP
.Vb 5
\&        'style' is obviously the style describing the presentation
\&        characteristics to give to it. See OODoc::Styles for how to construct
\&        styles by program or to replicate existing styles. Remember that a
\&        style must belong to the 'text' family in order to be used in this
\&        context (for example, a paragraph style would not work).
.Ve
.PP
.Vb 3
\&        As a highlighted string can be quite long or not all known in
\&        advance, you can represent it with a regular expression. Taking the
\&        following paragraph as an example:
.Ve
.PP
.Vb 1
\&        "OpenOffice.org includes Writer, Calc, Draw and Impress"
.Ve
.PP
.Vb 3
\&        Assuming this text is contained in a $p element, the following
\&        instruction gives the "Highlight" style to the "OpenOffice.org",
\&        "Writer", "Calc", "Draw", and "Impress" substrings:
.Ve
.PP
.Vb 6
\&                $doc->setSpan
\&                    (
\&                    $p,
\&                    'OpenOffice\e.org|Writer|Draw|Calc|Impress',
\&                    "Highlight"
\&                    );
.Ve
.PP
.Vb 3
\&        The style referred to by setSpan() may be an existing style as well
\&        as a style to be defined by the program (see createStyle() in
\&        OpenOffice::OODoc::Styles).
.Ve
.PP
.Vb 7
\&        setSpan() works on any kind of text container, whatever its
\&        hierarchical level. For example, if the given element is a table,
\&        the span style attribution applies to every cell of the table. And
\&        the same change can be done in all the displayable content not
\&        including page headers, page footers, and page backgrounds through
\&        a single setSpan() call, if the given element is the document body
\&        itself (see getBody() in OpenOffice::OODoc::XPath).
.Ve
.PP
.Vb 3
\&        Caution: this method can neither recognise nor handle a string
\&        located partly in a "span" and partly outside it. It can, however,
\&        create a "span" inside another.
.Ve
.PP
.Vb 1
\&        See also removeSpan() and setHyperlink().
.Ve
.PP
\fIsetStyle(path, position, style_name)\fR
.IX Subsection "setStyle(path, position, style_name)"
.PP
\fIsetStyle(element, style_name)\fR
.IX Subsection "setStyle(element, style_name)"
.PP
.Vb 1
\&        Obsolete. See textStyle.
.Ve
.PP
\fIsetText(element, text ,[text, ...])\fR
.IX Subsection "setText(element, text ,[text, ...])"
.PP
.Vb 2
\&        Alters the setText method of OODoc::XPath, so that it can handle
\&        complex text elements.
.Ve
.PP
.Vb 3
\&        If the element is a paragraph, a header or a list item (ordered or
\&        unordered), its content is replaced by the 'text' argument. Caution:
\&        setText() deletes and replaces the previous content of the paragraph.
.Ve
.PP
.Vb 2
\&        If the element is a table cell, this method is the same as
\&        updateCell.
.Ve
.PP
.Vb 4
\&        If the element is a list (ordered or unordered), the content of each
\&        'text' argument (however many) forces the creation of a new item
\&        which is appended to the list (existing items remain unchanged).
\&        Example:
.Ve
.PP
.Vb 1
\&            $doc->setText($element, "Peter", "Paul", "John")
.Ve
.PP
.Vb 3
\&        adds three items to the list if $element is a list. If $element is,
\&        for example, a paragraph, then the second argument ("Peter") becomes
\&        the content of the paragraph and the other arguments are ignored.
.Ve
.PP
.Vb 2
\&        If the element is a note element or a note body, the given text
\&        becomes the content of the note body.
.Ve
.PP
.Vb 2
\&        If the element is a section, the whole content of the section is
\&        deleted and replaced by a single paragraph containing the given text.
.Ve
.PP
.Vb 2
\&        For all other types of $element, setText() behaves normally as defined
\&        in OODoc::XPath.
.Ve
.PP
.Vb 4
\&        Note: setText(), as any other text input method, can't properly
\&        process repeated spaces. So, a sequence of spaces, whatever its
\&        length, is replaced by a single space. See setText() and extendText()
\&        in OpenOffice::OODoc::XPath.
.Ve
.PP
\fIsetTextBoxContent(text_box, content)\fR
.IX Subsection "setTextBoxContent(text_box, content)"
.PP
.Vb 1
\&        Fills the given text box according to the given content.
.Ve
.PP
.Vb 3
\&        The first argument may be the unique name, the order number or the
\&        reference of a text box. The content is processed in the same way
\&        as the content option in createTextBox().
.Ve
.PP
\fIsetTextField(element, [context,] expression, field-type [, options])\fR
.IX Subsection "setTextField(element, [context,] expression, field-type [, options])"
.PP
.Vb 3
\&        Replaces one or more substrings of a given text element by a variable
\&        text field. See textField() in the present manual chapter for some
\&        information about text fields.
.Ve
.PP
.Vb 3
\&        This method works the same way as setSpan() to retrieve the strings
\&        to be replaced. However, each matching string becomes invisible and
\&        is replaced by the variable field.
.Ve
.PP
.Vb 2
\&        Optional field attributes are allowed after the field type in the same
\&        conditions as for textField().
.Ve
.PP
.Vb 3
\&        The following example replaces every occurrence of "TIMESTAMP" in a
\&        given section by a variable field displaying a time which is 2 hours
\&        later than the current time:
.Ve
.PP
.Vb 6
\&                $section = $doc->getSection("Variables");
\&                $doc->setTextField
\&                        (
\&                        $section, "TIMESTAMP", 'time',
\&                        'time-adjust' => 'PT02H'
\&                        );
.Ve
.PP
\fItableName(table [, newname])\fR
.IX Subsection "tableName(table [, newname])"
.PP
.Vb 3
\&        Returns the current name of a given table, or replaces it with a new
\&        name given as the second argument. The table can be indicated
\&        by number, logical name or reference.
.Ve
.PP
.Vb 1
\&        Returns undef unless the given table is defined.
.Ve
.PP
.Vb 2
\&        If the new name is the name of an existing table, the table is not
\&        renamed and an error message is produced.
.Ve
.PP
\fItextBoxCoordinates(text_box [, new_coord])\fR
.IX Subsection "textBoxCoordinates(text_box [, new_coord])"
.PP
.Vb 3
\&        Gets or sets the position of a text box. The new coordinates, if
\&        any, must be provided using the same syntax and units as with
\&        the "position" option in createTextBox().
.Ve
.PP
\fItextBoxDescription(text_box, [, new_desc])\fR
.IX Subsection "textBoxDescription(text_box, [, new_desc])"
.PP
.Vb 2
\&        Gets or sets the optional description (long label) of the given
\&        text box.
.Ve
.PP
\fItextBoxName(text_box [, new_name])\fR
.IX Subsection "textBoxName(text_box [, new_name])"
.PP
.Vb 5
\&        Allows the applications to get the name of the given text box
\&        (which makes sense if the name is unknown, i.e. if the first
\&        argument is the element reference or the order number and not
\&        the name itself, of course). If a literal is passed as a second
\&        argument, the text box is renamed accordingly.
.Ve
.PP
\fItextId(element [, text_id])\fR
.IX Subsection "textId(element [, text_id])"
.PP
.Vb 3
\&        This accessor gets or sets the "text identifier", an optional
\&        attribute of any text container. This attribute is presently used
\&        for a few elements by OpenOffice.org (ex: the notes).
.Ve
.PP
.Vb 6
\&        With one argument only, returns the existing identifier of the given
\&        element, or undef if the element doesn't own a text identifier.
\&        If a second argument is provided, its value replaces any previous
\&        value of the identifier, and the text identifier is created if needed.
\&        The new value is not checked, so the application should take care of
\&        its uniqueness.
.Ve
.PP
.Vb 2
\&        The text identifier can be used as a bookmark, knowing that, unlike a
\&        bookmark, this attribute is not visible for the end user.
.Ve
.PP
.Vb 1
\&        See also selectElementByTextId().
.Ve
.PP
.Vb 3
\&        Caution: The text identifiers created or changed by other applications
\&        are presently *not* preserved when the document is edited through
\&        OpenOffice.org.
.Ve
.PP
\fItableStyle(table [, style])\fR
.IX Subsection "tableStyle(table [, style])"
.PP
.Vb 3
\&        Returns the current style of a given table, or replaces it with a
\&        new style given as the second argument. The table can be indicated
\&        by number, logical name or reference.
.Ve
.PP
\fItextField(type [, options])\fR
.IX Subsection "textField(type [, options])"
.PP
.Vb 2
\&        Creates and returns a variable field to be inserted within a text
\&        element.
.Ve
.PP
.Vb 9
\&        Such a field doesn't contain any static text by itself. When
\&        included in a text container, it tells the editing/printing software
\&        to display dynamic context data, such as date, time, file name,
\&        page number, page count, author, etc. Variable text fields are mainly
\&        used in page headers or footers, but they are allowed in the page
\&        bodies as well. Remember that a text field must be attached as a child
\&        element of a text container (paragraph or heading) in order to be
\&        displayed. However, the text container itself may be attached to
\&        anything anywhere (ex: a page header, a table cell, a list item, etc).
.Ve
.PP
.Vb 3
\&        The first argument (mandatory) is the field type. Many field types
\&        are allowed, so they are not all listed here. For some of them,
\&        options are allowed or required.
.Ve
.PP
.Vb 3
\&        To get the full list of field types, and their possible options,
\&        look at the chapter 6 "Text fields" in the OpenDocument 1.0
\&        specification. However, a few ones are presented below as examples.
.Ve
.PP
.Vb 5
\&        The field type, as well as each field option, must be provided as it
\&        appears in the OpenDocument specification, without the "text:" prefix
\&        (this prefix is automatically added). However, the application can
\&        force any arbitrary field name and/or field option such as 'xxx:yyy'
\&        (any name or option including a ':' is accepted as is).
.Ve
.PP
.Vb 7
\&        Caution: textField() allows the user to create any kind of field,
\&        without OpenDocument compliance check. So it can be used to insert
\&        application-specific markup in any place. This feature could prove
\&        useful in some situations, but remember that a typo in a field type
\&        or option will not be automatically detected. In the other hand, every
\&        non-OpenDocument field is silently removed if the document is later
\&        edited and saved through OpenOffice.org.
.Ve
.PP
.Vb 4
\&        Knowing that the created element is not attached to a text container,
\&        it must be inserted or appended through another method. For example,
\&        the following sequence creates a paragraph displaying "This document
\&        contains <page-count> pages and we are in the page <page-number>":
.Ve
.PP
.Vb 10
\&                $para = $doc->appendParagraph
\&                        (
\&                        text => "This document contains ",
\&                        style => "Standard"
\&                        );
\&                $pg = $doc->textField('page-count');
\&                $doc->appendElement($para, $pg);
\&                $doc->extendText($para, " pages and we are in the page ");
\&                $pg = $doc->textField('page-number');
\&                $doc->appendElement($para, $pg);
.Ve
.PP
.Vb 4
\&        The 'page-number' field type, introduced above, could be adjusted in
\&        order to display the page number of any following or preceding page.
\&        To do so, a 'page-adjust' option, set with a positive or negative
\&        integer value, should be provided to createField():
.Ve
.PP
.Vb 2
\&                $pg = $doc->textField
\&                        ('page-number', 'page-adjust' => -2);
.Ve
.PP
.Vb 3
\&        Note that, if the arithmetic sum of the real page number and the
\&        'page-adjust' value doesn't match an existing page, the editing
\&        application should display nothing.
.Ve
.PP
.Vb 7
\&        As another example, a 'chapter' field displays the current chapter
\&        number or title. It requires 2 options: 'outline-level', an integer
\&        which selects the hierarchical heading level to be regarded as the
\&        chapter level, and 'display' which controls the value to display
\&        (chapter number, chapter name or both). The following instruction
\&        creates a field displaying the number and the name of the current
\&        level 1 heading:
.Ve
.PP
.Vb 6
\&                $chapter_field = $doc->textField
\&                        (
\&                        'chapter',
\&                        'outline-level' => 1,
\&                        'display'       => 'number-and-name'
\&                        );
.Ve
.PP
.Vb 4
\&        Other possible fields display the current date or time (see the
\&        setTextField() example about a time field with an optional ajustment),
\&        the author's name, the file path or name, and many other variable or
\&        fixed values, according to many options.
.Ve
.PP
\fItextStyle(path, position [, style])\fR
.IX Subsection "textStyle(path, position [, style])"
.PP
\fItextStyle(element [, style])\fR
.IX Subsection "textStyle(element [, style])"
.PP
.Vb 3
\&        Reads a text element's style or, if a 'style' argument is given,
\&        changes it. The text element may be a section, paragraph, a header,
\&        or a span included in a paragraph or a header.
.Ve
.PP
.Vb 2
\&        The element can be indicated by the pair [path, position] or by
\&        reference.
.Ve
.PP
.Vb 2
\&        Note: the returned value is a literal style identifier or the value
\&        of the element's 'text:style-name' attribute.
.Ve
.PP
.Vb 7
\&        Note: this method allows you to attribute a non-existent style to a
\&        paragraph or header. Such a style can be created later (e.g. using
\&        createStyle) or not at all. The actual existence of the style is
\&        only relevant to the needs of the application. Obviously,
\&        opening a document which contains references to non-existent styles
\&        in OpenOffice.org will give unpredictable results as to the viewing
\&        of the given paragraphs or headers.
.Ve
.PP
\fIunlockSection(section)\fR
.IX Subsection "unlockSection(section)"
.PP
.Vb 3
\&        Removes the write protection (if any) of the given section. If the
\&        section was key-protected, the key is removed and provides the return
\&        value of the method.
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 2
\&                my $key = $doc->unlockSection("Section1");
\&                $doc->lockSection("Section2", $key);
.Ve
.PP
.Vb 2
\&        The two lines above remove the protection of "Section1" and protect
\&        "Section2" with the password which previously protected "Section1".
.Ve
.PP
\fI\fIunlockSections()\fI\fR
.IX Subsection "unlockSections()"
.PP
.Vb 1
\&        Removes the write protection of every section in the document.
.Ve
.PP
\fIupdateCell(table, row, column, value [, text])\fR
.IX Subsection "updateCell(table, row, column, value [, text])"
.PP
\fIupdateCell(element, value [, text])\fR
.IX Subsection "updateCell(element, value [, text])"
.PP
.Vb 1
\&        Modifies the content of a table cell.
.Ve
.PP
.Vb 3
\&        In its first form, indicates a cell by its 3D coordinates, as with
\&        getCell(). In its second form, indicates a cell by its element
\&        reference.
.Ve
.PP
.Vb 3
\&        If the cell is set to literal, its content is limited to its text.
\&        In this case, the optional argument "text" is of no use (the text
\&        equals the value).
.Ve
.PP
.Vb 2
\&        If the cell is set to numeric (float, currency, date, etc.), you
\&        should generally pass a literal argument as well as the value.
.Ve
.PP
.Vb 2
\&        This method can be replaced by the accessor cellValue which allows
\&        reads and writes.
.Ve
.PP
\fIuserFieldValue(user_field [, value])\fR
.IX Subsection "userFieldValue(user_field [, value])"
.PP
.Vb 4
\&        Reads the stored value of a given user field or changes it if a
\&        value is provided. The 1st argument can be either the name of the
\&        field (as it appears for the end-user) or a previously loaded
\&        user field element. See also getUserFieldElement().
.Ve
.PP
.Vb 2
\&        This method doesn't create any new user field. It can only read or
\&        update an existing one.
.Ve
.PP
.Vb 5
\&        If the given user field is numeric (ex: date, currency) the returned
\&        and/or provided value is the internally stored value, and not the
\&        displayed one. The user field is displayed according to a data style
\&        by OpenOffice.org. For example, 'Tuesday, March 1, 2005' is a possible
\&        displayed value for 38412.
.Ve
.PP
\fIvariableValue(name/element [, newvalue])\fR
.IX Subsection "variableValue(name/element [, newvalue])"
.PP
.Vb 3
\&        Returns the current value of the given user-defined variable or, if
\&        a new value is provided as the second argument, updates the variable
\&        accordingly.
.Ve
.PP
.Vb 1
\&        [Contribution by Andrew Layton]
.Ve
.Sh "OpenOffice::OODoc::Element methods"
.IX Subsection "OpenOffice::OODoc::Element methods"
.Vb 6
\&        While all the methods above belong to the document object, some
\&        additional methods are defined for individual text containers. These
\&        methods belong to the OpenOffice::OODoc::Element class. The most
\&        general of them are described in the OpenOffice::OODoc::XPath manual.
\&        Some of them (listed below) are simple read-only accessors allowing
\&        the user to check the type of any element.
.Ve
.PP
\fI\fIisXXX()\fI methods\fR
.IX Subsection "isXXX() methods"
.PP
.Vb 3
\&        A set of "isXXX" methods, returning true or false, allow to check
\&        the type of a given element. Caution, this methods belong to the
\&        elements, not to the document.
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 1
\&            print "This is a list" if $element->isItemList;
.Ve
.PP
.Vb 1
\&        Here is the list of element type indicators:
.Ve
.PP
.Vb 1
\&            isBibliographyMark          bibliography mark (in the doc. body)
.Ve
.PP
.Vb 1
\&            isCovered                   covered (invisible) table cell
.Ve
.PP
.Vb 1
\&            isDrawPage                  presentation or drawing page
.Ve
.PP
.Vb 1
\&            isEndnote                   endnote main element
.Ve
.PP
.Vb 1
\&            isEndnoteBody               endnote body element
.Ve
.PP
.Vb 1
\&            isEndnoteCitation           endnote citation element
.Ve
.PP
.Vb 1
\&            isFootnote                  footnote main element
.Ve
.PP
.Vb 1
\&            isFootnoteBody              footnote body element
.Ve
.PP
.Vb 1
\&            isFootnoteCitation          footnote citation element
.Ve
.PP
.Vb 1
\&            isHeading                   heading
.Ve
.PP
.Vb 1
\&            isItemList                  list (ordered or unordered)
.Ve
.PP
.Vb 1
\&            isListItem                  list item
.Ve
.PP
.Vb 1
\&            isNote                      main note element (end- or footnote)
.Ve
.PP
.Vb 1
\&            isNoteBody                  note body (in end- or footnote)
.Ve
.PP
.Vb 1
\&            isOrderedList               ordered list (OOo only)
.Ve
.PP
.Vb 1
\&            isParagraph                 paragraph
.Ve
.PP
.Vb 1
\&            isSection                   section
.Ve
.PP
.Vb 1
\&            isSequenceDeclarations      set of sequence declarations
.Ve
.PP
.Vb 1
\&            isSpan                      span element (see setSpan)
.Ve
.PP
.Vb 1
\&            isTable                     table
.Ve
.PP
.Vb 1
\&            isTableCell                 table cell
.Ve
.PP
.Vb 1
\&            isTableRow                  table row
.Ve
.PP
.Vb 1
\&            isUnorderedList             unordered list (OOo only)
.Ve
.PP
\fIOther element methods\fR
.IX Subsection "Other element methods"
.PP
.Vb 6
\&        For a neater and more direct access to element types, see the
\&        getName method of XML::Twig::Elt. A call to $element->getName
\&        returns the element's XML name including its namespace prefix
\&        e.g. 'text:p' for a paragraph or 'table:table-row' for a table
\&        row. Remember that all the features of XML::Twig::Elt are
\&        available for any text container.
.Ve
.Sh "Properties"
.IX Subsection "Properties"
.Vb 1
\&        No class variables are exported.
.Ve
.PP
.Vb 1
\&        Instance properties are the same as for OODoc::XPath, plus:
.Ve
.PP
.Vb 1
\&            'delimiters'        => delimiter table
.Ve
.PP
.Vb 2
\&        hash giving the relation between element types and the delimiters to
\&        use when exporting text (see getText).
.Ve
.PP
.Vb 1
\&            'use_delimiters'    => delimiter usage (see getText)
.Ve
.PP
.Vb 3
\&        indicates whether delimiters are to be used by getText or not when
\&        exporting text. Set to 'on' by default. Can be set to 'off' or
\&        another value to stop or limit use of delimiters.
.Ve
.PP
.Vb 1
\&            'heading_style'     => default header style
.Ve
.PP
.Vb 2
\&        indicates the default header style to be used by element creation
\&        methods when no style is specified. Set to 'Heading 1' by default.
.Ve
.PP
.Vb 1
\&            'paragraph_style'   => default paragraph style
.Ve
.PP
.Vb 2
\&        indicates the default paragraph style to be used by element creation
\&        methods when no style is specified. Set to 'Standard' by default.
.Ve
.PP
.Vb 1
\&            'field_separator'   => field separator
.Ve
.PP
.Vb 2
\&        contains the character string to be used as the field separator when
\&        exporting tables. By default it is ";".
.Ve
.PP
.Vb 1
\&            'line_separator'    => line separator
.Ve
.PP
.Vb 2
\&        contains the string to be used to separate lines when exporting
\&        "flat" text. By default, it is a line-feed ("\en").
.Ve
.PP
.Vb 2
\&            'max_rows'          => max table length (default 32)
\&            'max_cols'          => max table width (default 26)
.Ve
.PP
.Vb 4
\&        these 2 properties control the size of the "managed area" in a
\&        spreadsheet; the default "managed area" is the A1:Z31 rectangle,
\&        corresponding to the (0,0)-(31,25) coordinates; see getTable() and
\&        getCell() and normalizeSheet() for more explanations.
.Ve
.PP
.Vb 1
\&            'expand_tables'     => table transformation usage
.Ve
.PP
.Vb 9
\&        indicates whether the XML representation of the spreadsheets are to
\&        be expanded in order to allow the same cell/row addressing scheme
\&        as with the tables belonging to text documents; by default, this
\&        property is not set. If this property is set to 'on', the first
\&        access to any sheet will automatically trigger this transformation,
\&        so the explicit normalizeSheet() method will not be needed.
\&        However, this automatic (but costly) transformation has a drawback:
\&        it uses the same 'max_rows' and 'max_cols' values for every targeted
\&        sheet, whatever the really needed managed area for each one.
.Ve
.SH "AUTHOR/COPYRIGHT"
.IX Header "AUTHOR/COPYRIGHT"
Developer/Maintainer: Jean-Marie Gouarne <http://jean.marie.gouarne.online.fr>
.PP
Contact: jmgdoc@cpan.org
.PP
Copyright 2004\-2006 by Genicorp, S.A. <http://www.genicorp.com>
.PP
Initial English version of the reference manual by Graeme A. Hunter
(graeme.hunter@zen.co.uk).
.PP
License:
.PP
.Vb 2
\&        - Licence Publique Generale Genicorp v1.0
\&        - GNU Lesser General Public License v2.1
.Ve
