.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OODoc::XPath 3pm"
.TH OODoc::XPath 3pm "2007-05-11" "perl v5.8.4" "User Contributed Perl Documentation"
.SH "NAME"
OpenOffice::OODoc::XPath \- Low\-level navigation in the documents
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is a low-level class which uses OODoc::File (without
inheriting anything from it) along with the classes defined in the
XML::Twig module. It's a common basis for the other, more user\-
friendly, document-oriented modules. It uses XPath expressions in
order to retrieve any document element (but it doesn't provide a
full implementation of the XPath standard). In addition, while the
most part of the provided methods are OpenDocument\-aware, this module
could be used against any other kind of \s-1XML\s0 documents, simply because
it benefits from all the features of XML::Twig. Such a possibility
may prove useful for applications that simultaneously process OpenDocument
and non-OpenDocument \s-1XML\s0 files.
.PP
The OpenOffice::OODoc::XPath class should not be explicitly used in the
applications, because all its features are available in more user-friendly
classes such as OODoc::Text, OODoc::Styles, OODoc::Image, OODoc::Document
and OODoc::Meta. The present manual page is provided to describe the
common methods and properties that are available with all these classes.
.PP
This chapter can be skipped by programmers who are only interested
in upper level methods provided by the OODoc::Text, ::Styles, ::Image and
::Meta modules. Understanding these modules is easier and using them
requires less Perl and \s-1XML\s0 expertise. However, calling OODoc::XPath methods
remains a good rescue option as it allows all kinds of operations on all types
of \s-1XML\s0 elements contained in any OpenDocument-compliant file.
.PP
OODoc::XPath is the common foundation of OODoc::Meta, OODoc::Text,
OODoc::Styles and OODoc::Image. It contains the lowest layer of
navigation services for \s-1XML\s0 documents and handles the link with
OODoc::File for file access. Its primary role is as an interface
with the XML::Twig \s-1API\s0.
.PP
In the present manual chapter, you will see \*(L"elements\*(R" often mentioned.
When it says that a module expects a parameter or returns an element
(either singly or as a list), it is referring to an \s-1XML\s0 element.
It is important to distinguish elements from their content
(elements being simply references to \s-1XML\s0 data structures). To read
or modify the content of an element such as its text or \s-1XML\s0
attributes, use the accessors also available within OODoc::XPath.
.PP
In most cases where XPath methods require a reference to an element
as an argument, there are two ways of proceeding:
.PP
\&\- reference the element directly (obtained previously)
.PP
\&\- or give an XPath expression and a position, being a string and an
integer respectively; for example, the pair ('//office:body/text:p', 12)
or ('//text:p', 12) represents the thirteenth occurrence of the 'text:p'
element, i.e. the 13th paragraph (occurrences are numbered starting from 0).
.PP
The second way requires the knowledge of an appropriate XPath
expression (according the OOo/OpenDocument \s-1XML\s0 format specification).
And a given XPath expression is not necessarily the same with an
OpenDocument as in an OpenOffice.org document. So you should
preferently use high level accessors (provided by derivative classes
such as OODoc::Document) and avoid XPath hardcoding. However, you
know you can at any time reach any element with XPath.
.PP
Of course, you will never need to use XPath expressions in order to
reach the most common text elements (such as paragraphs), because the
OODoc::Text module provides more friendly accessors (for example, you
will probably use the \fIgetParagraph()\fR method and forget \*(L"//text:p\*(R").
.PP
Some methods accept both forms which means that if the first
parameter is recognised as an element reference, the position does
not need to be given. Therefore the number of arguments for certain
OODoc::XPath methods can vary.
.PP
For those who really want to access all areas there are also
OODoc::XPath methods which allow unrestricted access to every
element or \s-1XML\s0 attribute via an access path in XPath syntax. If you
are into this kind of thing, we recommend you obtain good syntax
reference manuals for XPath and OpenDocument and a supply of
aspirin.
.PP
Methods which may return several lines of text (e.g. getTextList) do
so either in the form of an unique character string containing \*(L"\en\*(R"
separators or in table form.
.PP
Unless otherwise stated, the word 'document' in this chapter only
refers to \s-1XML\s0 documents contained within OODoc::XPath objects and
not, say, OpenDocument files (as an end user would use).
.PP
Amongst the different methods which return elements, attributes or
text, some are called getXxx, others selectXxx or findXxx. Read
methods whose names start with \*(L"get\*(R" generally refer to an
unfiltered object or list, whereas others return an object or list
filtered according to a parameter value. In this latter case the
search parameter is treated as a standard expression and not an
exact value. This means that if the search criteria is \*(L"xyz\*(R", all
text containing \*(L"xyz\*(R" will be considered a match. To restrict the
search to text exactly equal to \*(L"xyz\*(R", use \*(L"^xyz$\*(R" as the search
criteria (following Perl regular expression syntax).
.PP
Several methods allow you to place copies of or references to
elements (from other documents or from other positions in the same
document) in any position in the current document. This offers
powerful manoeuvrability but only if these placements conform with
the destination position's context.
.PP
For example, you can easily copy a paragraph from one document
to another but only if you knowingly modify the paragraph's style
attribute if that style is not already defined in the destination
document. You can also copy the style but only if you are sure that
this style is not already defined by another unknown style in the
destination document (and so on).
.PP
For advanced users familiar with the XML::Twig \s-1API\s0, it might be
interesting to know that all the objects called \*(L"elements\*(R" in the
following chapters are objects of the OpenOffice::OODoc::Element
class, which is an XML::Twig::Elt derivative. So all methods associated
with this class are directly applicable to these elements, on top of the
functionality described in this manual. However, the knowledge of XML::Twig
is not mandatory.
.PP
Important note: The applications should not explicitly work with this
class. We recommend using OODoc::Meta and OODoc::Document (which are both
OODoc::XPath derivatives). These two objects provide highest-level methods
which are neater and more productive. Explicit use of OODoc::XPath methods
(which sometimes require large numbers of parameters) should only be
considered as a last resort in unexpected circumstances for access to any
element or \s-1XML\s0 attribute not handled by more friendly methods. However,
the present manual chapter could prove helpful because all the common
features of OODoc::Meta and OODoc::Document are described here.
.Sh "Methods"
.IX Subsection "Methods"
\fIConstructor : OpenOffice::OODoc::XPath\->new(<parameters>);\fR
.IX Subsection "Constructor : OpenOffice::OODoc::XPath->new(<parameters>);"
.PP
.Vb 1
\&        Short Form: ooXPath(<parameters>)
.Ve
.PP
.Vb 2
\&        Returns a new OpenDocument connector, i.e. an interface which
\&        can be used for subsequent operations on a well-formed document.
.Ve
.PP
.Vb 2
\&        This constructor should not be called directly; it's implicitly
\&        triggered each time a Meta or Document object is created.
.Ve
.PP
.Vb 4
\&        The document is loaded and parsed according to various options.
\&        The most used option is 'file'; it simply allows the application
\&        to process an OpenDocument file selected by its path/name in the
\&        file system.
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 7
\&                my $doc = ooXPath
\&                                (
\&                                file    => "myfile.ods",
\&                                member  => "content"
\&                                );
\&                # ... lot of processing ...
\&                $doc->save;
.Ve
.PP
.Vb 6
\&        Returns a new document connector. In the example above, the object
\&        is loaded from a regular OpenDocument file, that is the most current
\&        option, but there are other possibilities. It's possible to use
\&        flat XML (available as a string in memory, or loaded from a file).
\&        In addition, this constructor is able to create a new document
\&        from scratch.
.Ve
.PP
.Vb 4
\&        Because every feature of OODoc::XPath is inherited by OODoc::Document
\&        and OODoc::Meta (see the corresponding manual pages), ooXPath() is
\&        generally not explicitly invoked in a real application. Its silently
\&        used through ooDocument() or ooMeta().
.Ve
.PP
.Vb 4
\&        Parameters are named (hash key => value). The constructor must get
\&        at least one parameter giving a means of obtaining the XML document
\&        that it will represent. Several options are available; each one is
\&        represented through the following examples:
.Ve
.PP
.Vb 2
\&            # option 1 (using an existing flat XML document)
\&            my $doc = ooXPath(xml => $xml_string);
.Ve
.PP
.Vb 3
\&            # option 2 (using a previously created OOo file interface)
\&            my $oofile = ooFile('source.odt');
\&            my $doc = ooXPath(archive => $oofile, member => 'meta');
.Ve
.PP
.Vb 2
\&            # option 3 (using a regular OOo file directly)
\&            my $doc = ooXPath(file => 'source.odt', member => 'content');
.Ve
.PP
.Vb 4
\&            # option 4 (multiple instances against a single file)
\&            my $content = ooXPath(file => 'source.odt', member => 'content');
\&            my $meta = ooXPath(file => $content, member => 'meta');
\&            my $styles = ooXPath(file => $content, member => 'styles');
.Ve
.PP
.Vb 4
\&        Remember "ooXPath()" represents "OpenOffice::OODoc::XPath->new()" 
\&        in the instructions above, and you can (and should) use this shortcut
\&        provided that you have loaded the main OpenOffice::OODoc module, and
\&        not only and explicitly the OpenOffice::OODoc::XPath module.
.Ve
.PP
.Vb 4
\&        The first form uses an XML string directly (previously loaded or
\&        created by the program). To be used for very specific applications
\&        working with flat XML documents exports and not with standard
\&        OOo/OpenDocument files.
.Ve
.PP
.Vb 11
\&        The second method links OODoc::XPath to an existing OODoc::File
\&        object (so-called "archive" because it's a zip archive used through
\&        an object-oriented API) and indicates which XML member it is to
\&        extract (metadata, content, styles, etc). The OODoc::File is an
\&        abstraction of an already open OOo file. It can be shared, i.e.
\&        several OODoc::XPath objects can be instantiated with the same
\&        OODoc::File object, and this possibility must be used when
\&        several OODoc::XPath objects must bring consistent changes in
\&        a single file (see option 4 below). In order to create the
\&        required OODoc::File object, simply use ooFile() with a filename
\&        as argument (for advanced use, see OpenOffice::OODoc::File).
.Ve
.PP
.Vb 6
\&        The third method is the easiest, because the user just provide
\&        a filename and a member, and all the file interface is run silently
\&        (i.e. an invisible OODoc::File object is automatically created and
\&        used to get the content). It's probably the most used approach; its
\&        recommended when the user doesn't need to get more than one member
\&        in the same file.
.Ve
.PP
.Vb 4
\&        The 'member' or 'part' option is a selector that tells what component
\&        is needed (content, styles, metadata, ...) knowing that an
\&        OODoc::XPath object can handle only one component. Its default value
\&        is 'content'.
.Ve
.PP
.Vb 14
\&        If the application needs to process, say, the content and the styles
\&        in the same session, it must create two, or more, OODoc::XPath objects
\&        possibly associated with the same file interface. The appropriate way
\&        is shown in our last example above. The first instance is associated
\&        with a filename. Then the other instances are created with the first
\&        one, provided as the value of the 'file' option instead of a filename.
\&        The constructor tries to be user-friendly: if the 'file' value is
\&        a character string, it's regarded as a filename, but if this value,
\&        is an existing OpenOffice::OODoc::XPath object, the new object is
\&        automatically connected to the same file interface as the other one.
\&        The file interface is transparently provided by a common shared
\&        OpenOffice::OODoc::File object (you can safely ignore the features
\&        of this object, but a corresponding manual chapter is available for
\&        more details).
.Ve
.PP
.Vb 4
\&        Be careful: creating more than one OpenOffice::OODoc::XPath objects
\&        linked by their 'file' parameters to the same explicit filename (and
\&        not linked with each other) produces useless extra I/O operations and
\&        possible conflicts.
.Ve
.PP
.Vb 7
\&        Caution: being associated with a common interface via OODoc::File,
\&        none of these OODoc::XPath objects should be deleted before the final
\&        save() call for this archive. So by calling a save, the File object
\&        "calls up" all the XPath objects which were "connected" to it in order
\&        to "ask" each of them for the changes which were made to the XML
\&        (content, styles, meta, etc.). The results are unpredictable if any
\&        of them is absent when called.
.Ve
.PP
.Vb 5
\&        If the provided filename has a ".xml" or ".XML" suffix, or whatever
\&        the name if the 'flat_xml' option is set to 1, the file is processed
\&        as flat XML and not as a regular OOo file. No OODoc::File object is
\&        created, and the result of a subsequent call of the save() method
\&        produces a flat XML export (and not a regular OOo/OpenDocument file).
.Ve
.PP
.Vb 7
\&        You can pass the optional parameter 'element' in any case where the
\&        constructor is called without the 'xml' parameter. Bearing in mind
\&        that an OODoc::XPath object will not necessarily handle an entire
\&        XML document, this extra parameter indicates the name of the XML
\&        element to be loaded and handled. If the 'element' parameter is not
\&        given for an OpenDocument file, a default element will be chosen
\&        according to the following table:
.Ve
.PP
.Vb 5
\&            'meta'      => 'office:document-meta'
\&            'content'   => 'office:document-content'
\&            'styles'    => 'office:document-styles'
\&            'settings'  => 'office:document-settings'
\&            'manifest'  => 'manifest:manifest'
.Ve
.PP
.Vb 5
\&        Conversely, the 'element' parameter becomes mandatory if the chosen
\&        XML element is not listed above. Through OODoc::File, OODoc::XPath
\&        can actually access archives which are not necessarily in
\&        OpenDocument format and may be, for example, "databases" of
\&        presentation and content templates.
.Ve
.PP
.Vb 2
\&        If the application needs to create a new document, and not process
\&        an existing one, an additional option must be passed:
.Ve
.PP
.Vb 1
\&                create          => "class"
.Ve
.PP
.Vb 7
\&        where "class" must be one of the following list: "text",
\&        "spreadsheet", "presentation" or "drawing", according to the needed
\&        content class. And, for very special needs, the user can pass an
\&        additional "template_path" to select an ad hoc directory of XML
\&        templates instead of the default one. This user-provided directory
\&        must have the same kind of structure and content as the "templates"
\&        subdirectory of the OpenOffice::OODoc installation.
.Ve
.PP
.Vb 8
\&        An additional 'opendocument' option can be provided and set to 'true'
\&        or 'false'. If this option is 'false', the new document is created
\&        according to the OpenOffice.org 1.0 format instead of the OASIS
\&        OpenDocument format. The default format is OpenDocument. The
\&        'opendocument' option works for new documents only and is ignored
\&        unless the 'create' option. This module can create and process either
\&        OpenOffice.org 1.0 documents or ODF documents but can't directly
\&        convert a document from one format to the other one.
.Ve
.PP
.Vb 7
\&        OODoc::XPath can process OOo documents provided through XML flat
\&        files as well as in the compressed (zip) format. The given file is
\&        automatically processed as flat XML if either it's name ends by ".xml"
\&        or the 'flat_xml' option is set to '1'. When processing a flat XML
\&        file, OODoc::XPath doesn't load the OODoc::File zip interface. So,
\&        a subsequent call of the save() method can only export the document
\&        as flat XML.
.Ve
.PP
.Vb 4
\&        An optional 'readable_XML' can be passed. If this option is provided
\&        and set to 'on' or 'true', the resulting XML will be smartly indented
\&        (and, of course, more space-consuming). This feature is intended for
\&        debugging purposes and should not be used in production.
.Ve
.PP
.Vb 3
\&        The 'local_encoding' option can be set with the appropriate value
\&        when a particular character set (and not the default one) must be
\&        used for a document.
.Ve
.PP
.Vb 3
\&        A 'read_only' can be provided and set to 'true' in order to prevent
\&        the current member from being written back to the physical ODF file
\&        when the save() method is called.
.Ve
.PP
.Vb 2
\&        Other optional parameters can also be passed to the constructor (see
\&        Properties below).
.Ve
.PP
\fIappendElement(path, position, name/xml, [options]);\fR
.IX Subsection "appendElement(path, position, name/xml, [options]);"
.PP
\fIappendElement(element, name/xml, [options]);\fR
.IX Subsection "appendElement(element, name/xml, [options]);"
.PP
.Vb 3
\&        Adds a new element or existing element to the list of child elements
\&        of an existing parent element given first (by [path, position] or by
\&        reference).
.Ve
.PP
.Vb 1
\&        The argument after the position argument can be an XML element name.
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 5
\&            $content->appendElement
\&                (
\&                '//office:body', 0, 'text:p',
\&                text => "New text"
\&                );
.Ve
.PP
.Vb 4
\&        adds a paragraph containing the phrase "New text" to the end of the
\&        document body. (Remember that in the case of an OpenDocument text
\&        file (Writer), it would be better to use the appendParagraph method of
\&        OpenOffice::OODoc::Text as this requires fewer parameters.
.Ve
.PP
.Vb 2
\&        If the 'text' option is omitted, an empty element is created (in the
\&        above example it would be an empty paragraph or line feed).
.Ve
.PP
.Vb 5
\&        You can pass the 'attribute' or 'attributes' option which is a hash
\&        whose keys are the XML attribute names and whose values are the XML
\&        attribute values. Use of these options depends on the type of
\&        document and the type of element and requires knowledge of
\&        OpenDocument conventions.
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 5
\&            $my_style   =
\&                {
\&                'style:name'    => 'P1',
\&                'style:family   => 'paragraph'
\&                };
.Ve
.PP
.Vb 5
\&            $content->appendElement
\&                (
\&                '//office:automatic-styles', 0, 'style:style',
\&                attribute       => $my_style
\&                );
.Ve
.PP
.Vb 3
\&        creates a new paragraph style called 'P1' in the list of "automatic
\&        styles" ("automatic styles" are styles which are not explicitly
\&        indicated in the styles list as it appears to the end user).
.Ve
.PP
.Vb 4
\&        This method lets you add any kind of element into a document, even
\&        exotic ones. With the most common OpenDocument objects (e.g.
\&        paragraphs), though, it is easier to use the specialist methods
\&        contained in other modules.
.Ve
.PP
.Vb 8
\&        The 'name' argument can be replaced by an existing element in the
\&        same OODoc::XPath object or in another. In which case no element is
\&        created but the existing element is simply referenced with a new
\&        position even though it remains in its old position. Caution: any
\&        modification of an element which is referenced several times in one
\&        or more documents is made to all references. If you want to add a
\&        similar but separate element, you must use replicateElement which
\&        produces a new element from the content of an existing one.
.Ve
.PP
.Vb 13
\&        The 'name' argument can also be replaced by an XML string. This
\&        string must correspond to the correct XML description of a UTF-8
\&        encoded OpenDocument element. For example, it could be a
\&        string which had been previously exported using the exportXMLElement
\&        method of OODoc::XPath, or extracted from an OpenDocument file by
\&        some other application. If for any reason you absolutely have to
\&        use a non-UTF8 XML string which contains 8-bit characters (accented
\&        letters, etc.), you can always convert the string using the
\&        encode_text method before passing it to appendElement. Of course,
\&        the problem will not arise if you are absolutely sure that the string
\&        only contains ASCII (7 bit) characters. XML syntax is checked, but it
\&        is up to the user to verify that the element import conforms to
\&        OpenDocument XML grammar.
.Ve
.PP
.Vb 2
\&        The following piece of code produces the same result as the first
\&        example:
.Ve
.PP
.Vb 7
\&            $xml = '<text:p text:style-name="Standard">' .
\&                'New text' .
\&                '</text:p>';
\&            $content->appendElement
\&                (
\&                '//office:body', 0, $xml
\&                );
.Ve
.PP
.Vb 3
\&        Using this method, after one or more element creations by direct
\&        importation of XML strings, it might be useful to call the
\&        reorganize method (but not absolutely necessary).
.Ve
.PP
\fIappendLineBreak(element)\fR
.IX Subsection "appendLineBreak(element)"
.PP
.Vb 3
\&        Appends a line break to a text element. This method allows the user
\&        to create a single text element (ex: a paragraph) including one or
\&        more breaks, instead of separate elements.
.Ve
.PP
.Vb 2
\&        The example below appends a new text in a new line to the end of
\&        an existing paragraph:
.Ve
.PP
.Vb 3
\&            my $p = $doc->getElement('//text:p', 5);
\&            $doc->appendLineBreak($p);
\&            $doc->extendText($p, 'A new line in the same paragraph');
.Ve
.PP
\fIappendSpaces(element, length)\fR
.IX Subsection "appendSpaces(element, length)"
.PP
.Vb 4
\&        Appends a sequence of multiple spaces to a text element, knowing that
\&        a string containing repeated spaces shouldn't be stored as is in a
\&        document (see setText() and spaces() for details about repeated
\&        spaces).
.Ve
.PP
\fIappendTabStop(element)\fR
.IX Subsection "appendTabStop(element)"
.PP
.Vb 1
\&        Appends a tab stop ("\et") to a text element.
.Ve
.PP
\fIblankSpaces(length)\fR
.IX Subsection "blankSpaces(length)"
.PP
.Vb 1
\&        See spaces().
.Ve
.PP
\fIcloneContent(oodoc_xpath_object)\fR
.IX Subsection "cloneContent(oodoc_xpath_object)"
.PP
.Vb 3
\&        Cancels the entire document contents of the current instance and
\&        replaces it with a reference to the contents of another OODoc::XPath
\&        object.
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 12
\&            $doc1       = OpenOffice::OODoc::XPath->new
\&                        (
\&                        file    => 'template.ods',
\&                        member  => 'styles'
\&                        );
\&            $doc2       = OpenOffice::OODoc::XPath->new
\&                        (
\&                        file    => 'sheet.ods',
\&                        member  => 'styles'
\&                        );
\&            $doc2->cloneContent($doc1);
\&            $doc2->save;
.Ve
.PP
.Vb 2
\&        This sequence replaces the styles and page layout of 'sheet.ods'
\&        with those of 'template.ods'.
.Ve
.PP
.Vb 6
\&        The above example could easily have been written without even using
\&        OODoc::XPath by acting directly on the files. For example, extract
\&        the 'styles.xml' member from 'template.ods' and insert it into
\&        'sheet.ods'. The use of OODoc::XPath and the cloneContent method
\&        guarantees that the transferred content corresponds to an
\&        OpenDocument document and allows reads/writes to it on the fly.
.Ve
.PP
.Vb 4
\&        Caution: the "cloned" content is not physically copied. Calling this
\&        method references one single physical content in two documents. Any
\&        modifications made to the content of either of these two documents
\&        applies equally to the other and vice-versa.
.Ve
.PP
\fIcontentClass([class name])\fR
.IX Subsection "contentClass([class name])"
.PP
.Vb 4
\&        Accessor to get or set the class of the document content. If the
\&        current member is a document content, returns its class according
\&        to the OpenDocument terminology, i.e. one of the following values:
\&        "text", "spreadsheet", "presentation", or "drawing".
.Ve
.PP
.Vb 2
\&        Returns an empty string if the current member is not a document
\&        content (if it's, for example, the "meta" or "styles" member).
.Ve
.PP
.Vb 1
\&        This accessor is read-only.
.Ve
.PP
\fIcreateSpaces(length)\fR
.IX Subsection "createSpaces(length)"
.PP
.Vb 1
\&        See spaces().
.Ve
.PP
\fIcreateElement(name, text)\fR
.IX Subsection "createElement(name, text)"
.PP
\fIcreateElement(xml)\fR
.IX Subsection "createElement(xml)"
.PP
.Vb 2
\&        Creates a new element without attributes which is not inserted in a
\&        document.
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 3
\&            my $element =
\&                $doc->createElement
\&                        ('my_element', 'its content');
.Ve
.PP
.Vb 2
\&        creates a new XML element without attributes and returns its
\&        reference.
.Ve
.PP
.Vb 2
\&        Instead of a name, the first argument can be the full XML
\&        description of the element. Example:
.Ve
.PP
.Vb 2
\&            my $element = $doc->createElement
\&                        ('<text:p>My text</text:p>');
.Ve
.PP
.Vb 2
\&        This new element is temporary: it is not linked to any document. It
\&        is destined to be used later by another method.
.Ve
.PP
.Vb 2
\&        The name can contain a namespace prefix which would look like this:
\&        'namespace:name'.
.Ve
.PP
.Vb 4
\&        In its second form, a well-formed XML string can be supplied as a
\&        single argument. The recognition criteria is the presence of the "<"
\&        character at the beginning of the argument. See appendElement for
\&        comments on the direct insertion of XML.
.Ve
.PP
.Vb 4
\&        Explicit calls to createElement should be rare. This method is
\&        normally called silently by higher-level methods which are capable
\&        of creating an element, inserting it in a document's XML tree and
\&        giving it attributes (see appendElement and insertElement).
.Ve
.PP
\fIcreateFrame(name => frame_name [, options])\fR
.IX Subsection "createFrame(name => frame_name [, options])"
.PP
.Vb 3
\&        Creates an empty frame. A frame is an OpenDocument object which
\&        controls a rectangular area where a visible content is displayed.
\&        Possible contents for a frame are text boxes or images.
.Ve
.PP
.Vb 4
\&        This method works is not focused on a particular document class
\&        (for example, it works on text documents as well as on presentations),
\&        but the visible effects of some options are not always exactly the
\&        same.
.Ve
.PP
.Vb 1
\&        Possible options are:
.Ve
.PP
.Vb 1
\&                'name'          => unique name
.Ve
.PP
.Vb 2
\&        The 'name' is an identifier; if provided, it should be unique for
\&        the document.
.Ve
.PP
.Vb 1
\&                'attachment'    => existing container
.Ve
.PP
.Vb 5
\&        The value of this option, if provided, must be an existing element
\&        which can contain a text box according to the OpenDocument rules.
\&        Such an object may be, for example, a draw page if the current
\&        document class is 'presentation' or 'drawing', or a paragraph if
\&        this class is 'text'.
.Ve
.PP
.Vb 1
\&                'page'          => page number or name
.Ve
.PP
.Vb 11
\&        The effects of the 'page' option depends on the content class of the
\&        current document. If this option is used, it indicates that the frame
\&        will be anchored to a page, and the given value is a page number.
\&        It does not matter if, when createFrame() is called, this number is
\&        beyond the end of the document or not. If the content class of the
\&        document is "presentation" (Impress) or "drawing" (Draw), then the
\&        page option must be either the visible name or the object reference
\&        of an existing draw page. Caution: the 'page' option is ignored if
\&        'attachment' is provided; in the other hand, either 'page' or
\&        'attachment' nust be provided in order to really include the new frame
\&        in the document.
.Ve
.PP
.Vb 1
\&                'position'      => coordinates
.Ve
.PP
.Vb 17
\&        The coordinates are provided as a string. They go from left to right
\&        and top to bottom. Coordinates should be given here in the form of a
\&        string "x,y", and the default unit is centimeter. You can choose
\&        any other OpenDocument-supported unit instead by attaching the
\&        corresponding usual abbreviation, such as "12.5cm, 35mm" which is the
\&        same as "125mm, 3.5cm" or "12.5,3.5", etc. The point ("pt") unit is
\&        allowed as well. The default coordinates are "0, 0". By default,
\&        the coordinates are relative to the anchor point. So, the coordinates
\&        are directly page-related if a valid 'page' option is provided only,
\&        but if the box is attached to, say, a paragraph, the origin of the
\&        coordinates is the beginning of the paragraph. However, the real
\&        interpretation of the coordinates depends on the style. With some
\&        style definitions, the coordinates may just be ignored (ex: if the
\&        style says "the frame is centered", OpenOffice.org will center the
\&        frame whatever its stored coordinates). According to other possible
\&        style definitions, the coordinates could be counted from the right
\&        and/or from the bottom and not from the left/top.
.Ve
.PP
.Vb 1
\&                'size'          => the size of the box
.Ve
.PP
.Vb 7
\&        Provided using as a string using the same syntax and units as the
\&        position, the 'size' option is strongly recommended knowing that a
\&        sizeless frame couldn't be properly displayed. The width comes
\&        first in the string. The height is sometimes ignored, according to
\&        the style of the frame: by default, the display height of a text box
\&        (which is a particular frame) is automatically adjusted to the
\&        content.
.Ve
.PP
.Vb 1
\&                'style'         => style name
.Ve
.PP
.Vb 5
\&        The 'style' option allows the application to set the frame style.
\&        Caution, a text style can't be used as a frame style. A frame
\&        style controls the box properties only (border, background, shadow,
\&        and so on), and not the content properties. Reusing an existing frame
\&        style through this option is generally a good idea.
.Ve
.PP
\fIcurrentContext([context])\fR
.IX Subsection "currentContext([context])"
.PP
.Vb 2
\&        Accessor allowing the application to change the context for some
\&        search methods (including getElement()).
.Ve
.PP
.Vb 3
\&        The default context is the root of the document. By setting the
\&        current context to a lower level object, the application can restrain
\&        the search to the descendants of this object.
.Ve
.PP
.Vb 3
\&        In the example below, the getElement() method retrieves a paragraph
\&        by order number in a previously selected section, and not in the whole
\&        document.
.Ve
.PP
.Vb 3
\&                my $section = $doc->getElement("//text:section", $s_number);
\&                $doc->currentContext($section);
\&                my $paragraph = $doc->getElement("//text:p", $p_number);
.Ve
.PP
.Vb 1
\&        Without argument, simply returns the previous current context.
.Ve
.PP
.Vb 1
\&        See also resetCurrentContext().
.Ve
.PP
\fIdecode_text(utf8_string)\fR
.IX Subsection "decode_text(utf8_string)"
.PP
.Vb 2
\&        Caution: this method is a non-exported class method. It must be used
\&        like this:
.Ve
.PP
.Vb 1
\&            OpenOffice::OODoc::XPath::decode_text($utf8_string);
.Ve
.PP
.Vb 1
\&        and not from an OODoc::XPath instance.
.Ve
.PP
.Vb 3
\&        Decodes a UTF-8 string and returns an 8 bit character translation
\&        of it out of the user's character set, as defined by the following
\&        variable:
.Ve
.PP
.Vb 1
\&            $OpenOffice::OODoc::XPath::LOCAL_CHARSET
.Ve
.PP
.Vb 2
\&        for which the default value is 'ISO-8859-1'. See the Perl/Encode
\&        manual for the list of supported character sets.
.Ve
.PP
.Vb 1
\&        OpenDocument uses UTF-8 XML encoding.
.Ve
.PP
.Vb 3
\&        Explicit calls to this method should be rare. It is used internally
\&        by methods which return text extracted from document content (e.g.
\&        getText).
.Ve
.PP
.Vb 3
\&        Warning to contributors: any method which returns text extracted
\&        from ODF documents is based on decode_text; so any modification or
\&        improvement of the decoding logic should be made there.
.Ve
.PP
\fIencode_text(editable_string)\fR
.IX Subsection "encode_text(editable_string)"
.PP
.Vb 1
\&        Class method.
.Ve
.PP
.Vb 1
\&        Encodes "local" character strings (for writing to ODF documents).
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 1
\&            $string = OpenOffice::OODoc::encode_text($local_string);
.Ve
.PP
.Vb 2
\&        The local character string is defined by the following global
\&        variable:
.Ve
.PP
.Vb 1
\&            $OpenOffice::OODoc::XPath::LOCAL_CHARSET
.Ve
.PP
.Vb 1
\&        for which the default value is 'ISO-8859-1'.
.Ve
.PP
.Vb 3
\&        Explicit calls to this method should generally be avoided. It is
\&        used internally by methods which insert text or attribute values
\&        into documents (e.g. setText).
.Ve
.PP
\fI\fIdispose()\fI\fR
.IX Subsection "dispose()"
.PP
.Vb 3
\&        Deletes the calling document object. Recommended as soon as the
\&        object is no longer needed by the application, and sometimes
\&        mandatory to avoid memory leaks, especially in long-running processes.
.Ve
.PP
\fI\fIexportXMLBody()\fI\fR
.IX Subsection "exportXMLBody()"
.PP
.Vb 2
\&        Returns the XML string for use by another application representing
\&        the body of a document, without UTF8 decoding.
.Ve
.PP
\fI\fIexportXMLContent()\fI\fR
.IX Subsection "exportXMLContent()"
.PP
.Vb 1
\&        See getXMLContent()
.Ve
.PP
\fIexportXMLElement(path, position)\fR
.IX Subsection "exportXMLElement(path, position)"
.PP
\fIexportXMLElement(element)\fR
.IX Subsection "exportXMLElement(element)"
.PP
.Vb 3
\&        Returns the XML string which represents a particular document
\&        element (style definition, paragraph, table cell, object, etc.) for
\&        use by another application without UTF8 decoding.
.Ve
.PP
.Vb 5
\&        This method is principally designed to allow remote exchanges of
\&        elements between programs using any XML storage or transfer method.
\&        It acts as "sender" whilst the "receiver" can use appendElement or
\&        insertElement (for example) to insert any exported elements into a
\&        document. Example:
.Ve
.PP
.Vb 5
\&            # sender programme
\&            # ...
\&            open (EXPORT, "> transfer.xml");
\&            print EXPORT $doc->exportXMLElement('//text:p', 15);
\&            close EXPORT;
.Ve
.PP
.Vb 5
\&            # receiver programme
\&            # ...
\&            open (IMPORT, "< transfer.xml");
\&            $doc->appendElement('//office:body', 0, <IMPORT>);
\&            close (IMPORT);
.Ve
.PP
.Vb 2
\&        In this example, a paragraph is transferred but it could just as
\&        easily be any content, presentation or metadata element.
.Ve
.PP
.Vb 6
\&        Conversely, this method is not needed when transferring an element
\&        from one document to another in the same program (or from one
\&        document position to another). An element can be copied directly
\&        from within the same program by reference or replication without
\&        going via its XML (see appendElement(), insertElement() and
\&        replicateElement()).
.Ve
.PP
\fIextendText(path, position, text [, offset])\fR
.IX Subsection "extendText(path, position, text [, offset])"
.PP
\fIextendText(element, text [, offset])\fR
.IX Subsection "extendText(element, text [, offset])"
.PP
.Vb 3
\&        Appends the given text to the previous content of the given
\&        element. If the optional 'offset' element is provided, the
\&        new element is inserted at the given position.
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 2
\&                $doc->setText($p, "Initial content");
\&                $doc->extendText($p, " extended");
.Ve
.PP
.Vb 2
\&        Assuming $p is a regular text element (ex: a paragraph), its
\&        content becomes "Initial content extended".
.Ve
.PP
.Vb 3
\&        If the second argument is an element itself, it's appended
\&        as is to the first element. This feature can be used, for
\&        example, in order to append sequences of repeated spaces:
.Ve
.PP
.Vb 4
\&                $doc->setText($p, "Begin");
\&                $spaces = $doc->spaces(6);
\&                $doc->extentText($p, $spaces);
\&                $doc->extendText($p, "End");
.Ve
.PP
.Vb 1
\&        After the code sequence above, the $p element contains:
.Ve
.PP
.Vb 1
\&                "Begin      End"
.Ve
.PP
.Vb 2
\&        knowing that a single string containing repeated spaces could
\&        not be properly processed by extendText() or setText().
.Ve
.PP
.Vb 1
\&        (See also setText()).
.Ve
.PP
\fIfindElementList(element, filter [, replacement])\fR
.IX Subsection "findElementList(element, filter [, replacement])"
.PP
.Vb 2
\&        Returns all the children of the given element whose content matches
\&        the given filter (regexp).
.Ve
.PP
.Vb 4
\&        If the third argument ('replacement') is given, every string which
\&        matches the filter in each child element will be replaced by this
\&        'replacement' value. This 'replacement' argument can be a character
\&        string or a function reference. (See replaceText() method below.)
.Ve
.PP
.Vb 2
\&        Filtering and possible replacement only affects an element's content
\&        and not its attributes.
.Ve
.PP
.Vb 2
\&        This method is mostly for internal use. We recommend using other
\&        methods for the selective extraction of elements.
.Ve
.PP
\fIflatten(element)\fR
.IX Subsection "flatten(element)"
.PP
.Vb 5
\&        Converts in place the content of the given element to a flat string,
\&        removing any structure. Same as $element->flatten() (see flatten()
\&        in the "Element methods" section below). If no element is provided,
\&        "flattens" the current context element, which is, by default, the
\&        root of the document (be careful !).
.Ve
.PP
\fIgetAttribute(path, position, name)\fR
.IX Subsection "getAttribute(path, position, name)"
.PP
\fIgetAttribute(element, name)\fR
.IX Subsection "getAttribute(element, name)"
.PP
.Vb 2
\&        Returns the 'name' value of the chosen element (or undef if name is
\&        not defined or if the element does not exist).
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 2
\&            my $style   =
\&             $doc->getAttribute('//text:p', 15, 'text:style-name');
.Ve
.PP
.Vb 1
\&        returns the style for paragraph 15.
.Ve
.PP
\fIgetAttributes(path, position)\fR
.IX Subsection "getAttributes(path, position)"
.PP
\fIgetAttributes(element)\fR
.IX Subsection "getAttributes(element)"
.PP
.Vb 2
\&        Returns a list of the element's attributes in the form of a hash
\&        whose keys are the attributes' XML names.
.Ve
.PP
\fI\fIgetBody()\fI\fR
.IX Subsection "getBody()"
.PP
.Vb 3
\&        Returns the root of the document body. The document body is the
\&        main container of all the displayable content not including page
\&        headers, page footers, and page backgrounds.
.Ve
.PP
\fIgetDescendants(tag [, context])\fR
.IX Subsection "getDescendants(tag [, context])"
.PP
.Vb 2
\&        Returns the list of the descendants of the given context element
\&        strictly matching the given tag. Example:
.Ve
.PP
.Vb 2
\&                my $section = $doc->getSection("SectionName");
\&                my @paragraphs = $doc->getDescendants('text:p', $section);
.Ve
.PP
.Vb 3
\&        Here, @paragraphs is the list of all the paragraphs which are the
\&        descendants (at every level) of a given section (the getSection()
\&        method is described in the OpenOffice::OODoc::Text chapter).
.Ve
.PP
.Vb 2
\&        If the second argument is not provided, the current context of the
\&        document is used (see currentContext()).
.Ve
.PP
\fIgetElement(path [, position [, context]])\fR
.IX Subsection "getElement(path [, position [, context]])"
.PP
.Vb 6
\&        This method is provided in order to allow the user to retrieve any
\&        element in any kind of XML document (ODF-compliant or not) using an
\&        application-provided XPath expression. It should be used with elements
\&        whose type is not explicitly supported by the more focused (and more
\&        user-friendly) methods, described in other manual chapters (::Text,
\&        ::Styles, ::Meta, and ::Document).
.Ve
.PP
.Vb 2
\&        It returns an element's reference from an XPath path and a position
\&        (or undef if the given xpath does not indicate an existing element).
.Ve
.PP
.Vb 4
\&        The position argument is used to select a particular element, in the
\&        order of the document, knowing that the given xpath expression could
\&        select a set of elements. Without it, getElement() returns the first
\&        element matching the given xpath.
.Ve
.PP
.Vb 4
\&        The XPath expression applies in the current context, and not always
\&        in the whole document (see currentContext()). However, if the
\&        reference of a previously selected element is provided as a third
\&        argument, the given element is used as the context.
.Ve
.PP
.Vb 2
\&        Position indicators start at 0 just like in Perl tables (and some
\&        other programming languages).
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 1
\&            my $p = $doc->getElement('//table:table', 0)
.Ve
.PP
.Vb 2
\&        indicates an element containing the first table of a text document
\&        or first sheet of a spreadsheet.
.Ve
.PP
.Vb 2
\&        Positions can also be counted backwards from the end by giving
\&        negative values, i.e. position -1 being the last element. Thus:
.Ve
.PP
.Vb 1
\&            my $h = $doc->getElement('//text:h', -2);
.Ve
.PP
.Vb 1
\&        indicates the second-last header of a text document.
.Ve
.PP
.Vb 3
\&        Note: None of the two examples above should be used in a real
\&        application, knowing that the ::Text module provides getTable() and
\&        getHeading() that do the job without XPath coding.
.Ve
.PP
.Vb 7
\&        When successful, this method ensures that the returned object is
\&        indeed an element and not another type of node (e.g. attribute,
\&        text, comment, etc.). Such an object is never a printable text; it's
\&        either a text container (whose content may be extracted using
\&        getText() or getFlatText()) or a non-text element (such as a style,
\&        a font declaration, a variable field, a document properties container,
\&        etc).
.Ve
.PP
\fIgetElementList(path)\fR
.IX Subsection "getElementList(path)"
.PP
.Vb 1
\&        Returns a list of all elements at a specified path.
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 1
\&            my @ref_summary = $doc->getElementList('//text:h');
.Ve
.PP
.Vb 2
\&        The above example returns a table containing all header elements of
\&        a text document.
.Ve
.PP
.Vb 6
\&        The path can of course be a more complex XPath expression
\&        stipulating, for example, a selection of attribute values. In most
\&        cases, you should avoid complicating things unnecessarily
\&        (especially in Text, Image and Styles modules), as there are methods
\&        for searching by element type, attribute and content which are much
\&        easier to use and avoid the need to supply XPath expressions.
.Ve
.PP
.Vb 2
\&        Note: the returned list contains elements in the sense of getElement
\&        and not a list of element contents.
.Ve
.PP
\fIgetFlatText(path, position)\fR
.IX Subsection "getFlatText(path, position)"
.PP
\fIgetFlatText(element)\fR
.IX Subsection "getFlatText(element)"
.PP
.Vb 3
\&        Like getText() below, but without rendering of possible tab stops,
\&        line breaks, repeated spaces, or any other markup. The returned text
\&        is a just a decoded flat string.
.Ve
.PP
\fIgetFrameElement(name/number)\fR
.IX Subsection "getFrameElement(name/number)"
.PP
.Vb 2
\&        Selects the frame identified by the given name, or by the given order
\&        number in the document context.
.Ve
.PP
\fIgetNodeByXPath(xpath_expression)\fR
.IX Subsection "getNodeByXPath(xpath_expression)"
.PP
\fIgetNodeByXPath(xpath_expression, context)\fR
.IX Subsection "getNodeByXPath(xpath_expression, context)"
.PP
\fIgetNodeByXPath(context, xpath_expression)\fR
.IX Subsection "getNodeByXPath(context, xpath_expression)"
.PP
.Vb 6
\&        A low-level method which returns the node corresponding to the given
\&        XPath expression, if it exists in the document. This method (which
\&        gives unrestricted access to the entire content of a document) is
\&        designed for use with the unexpected. You will obviously need to be
\&        familiar with XPath syntax (not documented here) as well as
\&        OpenDocument structure. See also selectNodesByXPath().
.Ve
.PP
\fIgetObjectCoordinates(object)\fR
.IX Subsection "getObjectCoordinates(object)"
.PP
.Vb 3
\&        Returns the coordinates (X, Y) of the target object, if any. This
\&        method makes sense with "positioned" objects, i.e. with frames and
\&        frame-like objects (images, text boxes).
.Ve
.PP
.Vb 3
\&        In an array context, the coordinates are returned as two distinct
\&        strings (horizontal, then vertical position). In a scalar context,
\&        the values are returned in a single string, and separated by a comma.
.Ve
.PP
.Vb 2
\&        See createFrameElement() for details about the coordinates and size
\&        units and notation.
.Ve
.PP
\fIgetObjectDescription(object)\fR
.IX Subsection "getObjectDescription(object)"
.PP
.Vb 3
\&        Returns the litteral description of a visible object. This method
\&        makes sense for frames or frame-like objects (such as images or
\&        text boxes).
.Ve
.PP
\fIgetObjectSize(object)\fR
.IX Subsection "getObjectSize(object)"
.PP
.Vb 2
\&        Returns the size of the given object, if any. This method works with
\&        frames and other frame-based objects, such as images and text boxes.
.Ve
.PP
.Vb 1
\&        In the returned data, the width comes first, followed by the height.
.Ve
.PP
.Vb 2
\&        The size is returned in the same way as the coordinates with
\&        getObjectCoordinates().
.Ve
.PP
\fI\fIgetRoot()\fI\fR
.IX Subsection "getRoot()"
.PP
.Vb 3
\&        Returns the absolute root element of the document. The root element
\&        contains any other visible or non visible object, including the
\&        document body (see getBody) and style definitions.
.Ve
.PP
\fIgetText(path, position)\fR
.IX Subsection "getText(path, position)"
.PP
\fIgetText(element)\fR
.IX Subsection "getText(element)"
.PP
.Vb 3
\&        Returns text in the local character set, possibly UTF-8 decoded,
\&        contained in the element given as an argument (by path/position or
\&        by reference). See also getFlatText().
.Ve
.PP
.Vb 1
\&        Two equivalent examples:
.Ve
.PP
.Vb 1
\&        # version 1
.Ve
.PP
.Vb 1
\&        my $element     = $doc->getElement('//text:p', 4);
.Ve
.PP
.Vb 1
\&        my $text        = $doc->getText($element);
.Ve
.PP
.Vb 1
\&        # version 2
.Ve
.PP
.Vb 1
\&        my $text        = $doc->getText('//text:p', 4);
.Ve
.PP
.Vb 6
\&        Version 2 is better if the only aim is to get the text from
\&        paragraph 4. Version 1 is better, however, if during the course of
\&        the program you want to perform other operations on the same
\&        paragraph. Giving an element's reference will mean avoiding element
\&        handling methods having to recalculate a reference from the XPath
\&        path.
.Ve
.PP
\fIgetTextList(path)\fR
.IX Subsection "getTextList(path)"
.PP
.Vb 1
\&        Returns text from all elements in the specified path.
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 1
\&            my $summary = $doc->getTextList('//text:h');
.Ve
.PP
.Vb 1
\&            my $report = $doc->getTextList('//text:span');
.Ve
.PP
.Vb 4
\&        The $summary variable contains a concatenation of all headers.
\&        $report contains all the words or character strings that "stand out"
\&        which the user has designated by their context, e.g. words in
\&        italics in a non-italic paragraph.
.Ve
.PP
.Vb 5
\&        In a list context, the returned data is a table, each of whose
\&        elements contains the text of an XML element. In a scalar context
\&        (as in our two examples), the returned value is a unique piece of
\&        editable text and each element's content is separated from that of
\&        the following element by a line feed.
.Ve
.PP
\fIgetXMLContent([filehandle])\fR
.IX Subsection "getXMLContent([filehandle])"
.PP
.Vb 1
\&        Without argument, returns a document's entire XML content.
.Ve
.PP
.Vb 2
\&        Exports the entire XML content of the current member to a flat file,
\&        if a file handle is provided.
.Ve
.PP
.Vb 1
\&        Note: the exported data are UTF8-encoded.
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 3
\&                open my $fh, ">:utf8", "myfile.xml";
\&                $doc->getXMLContent($fh);
\&                close $fh;
.Ve
.PP
.Vb 1
\&        Synonym: exportXMLContent()
.Ve
.PP
\fIgetXPathValue(xpath_expression)\fR
.IX Subsection "getXPathValue(xpath_expression)"
.PP
\fIgetXPathValue(context, xpath_expression)\fR
.IX Subsection "getXPathValue(context, xpath_expression)"
.PP
\fIgetXPathValue(xpath_expression, context)\fR
.IX Subsection "getXPathValue(xpath_expression, context)"
.PP
.Vb 3
\&        A low-level method which allows direct access to the value
\&        corresponding to the given XPath expression in a document. Character
\&        decoding is handled in the same way as with getText.
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 4
\&            $expression =       '//office:automatic-styles'     .
\&                        '/style:style'                  .
\&                        '[@style:style-name="P1"]'      .
\&                        '/@style:parent-style-name';
.Ve
.PP
.Vb 1
\&            print $doc->getXPathValue($expression);
.Ve
.PP
.Vb 4
\&        This sequence displays the name of the parent style of automatic
\&        style "P1" (if it exists within the document). Remember that more
\&        simple methods in Text and/or Styles modules would indeed produce
\&        the same result.
.Ve
.PP
.Vb 4
\&        The optional element reference "context" can be given as an argument
\&        either in first or second place. In this case, the search is limited
\&        to the section of the document tree below this given element. The
\&        default search area is the entire document.
.Ve
.PP
.Vb 3
\&        Just as with other methods which require XPath paths, this one is
\&        primarily for internal use. It should not be used by the majority of
\&        applications.
.Ve
.PP
\fIinsertElement(path, position, name/xml [, options])\fR
.IX Subsection "insertElement(path, position, name/xml [, options])"
.PP
\fIinsertElement(element, name/xml [, options])\fR
.IX Subsection "insertElement(element, name/xml [, options])"
.PP
.Vb 2
\&        Inserts a new element before or after the element specified by
\&        [path, position] or by reference.
.Ve
.PP
.Vb 6
\&        If the "name" argument is a literal, a new element with the name
\&        given is created and then inserted. If the same argument is a
\&        reference to an existing element, this element is then simply
\&        inserted at the position indicated. This method is useful either for
\&        adding new elements or for copying elements from one document to
\&        another or from one position to another within the same document.
.Ve
.PP
.Vb 3
\&        The position option allows you to choose the insertion point of the
\&        new element. Possible values are "before", "after" and "within" (the
\&        default is "before").
.Ve
.PP
.Vb 6
\&        If "position" is set to "within", the new element is inserted within
\&        the text of the target element, so an additional "offset" option (i.e.
\&        a numeric position in the string) is required. Caution: this feature
\&        is provided for a few special purposes only; inserting text elements
\&        within text strings is not the same as inserting text strings within
\&        text strings.
.Ve
.PP
.Vb 1
\&        Other options are:
.Ve
.PP
.Vb 1
\&            text        => "text of element"
.Ve
.PP
.Vb 1
\&            attribute   => $attributes
.Ve
.PP
.Vb 3
\&        The "attribute" (or "attributes") option is itself a hash reference
\&        containing one or more attributes in the form [name => value] as in
\&        appendElement.
.Ve
.PP
.Vb 2
\&        When successful, this method returns the inserted element's
\&        reference (else undef).
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 12
\&            my $attributes      =
\&                {
\&                'text:style-name'       => 'Heading 2',
\&                'text:level'            => '2'
\&                };
\&            $doc->insertElement
\&                (
\&                '//text:p', 4, 'text:h',
\&                position        => 'after',
\&                text            => 'New section',
\&                attribute       => $attributes
\&                );
.Ve
.PP
.Vb 2
\&        This sequence (in a text document) inserts a level 2 header
\&        'New section' immediately after paragraph 4.
.Ve
.PP
.Vb 7
\&        The $name argument can be replaced by an existing element. In this
\&        case a new reference to the existing element is inserted, without
\&        creating a whole new element. In this way you can display an element
\&        at several locations or in several documents which is held in memory
\&        only once. See the appendElement section for the consequences of
\&        having multiple references to the same physical element. Better to
\&        use replicateElement to insert separate copies of an element.
.Ve
.PP
.Vb 2
\&        In the same conditions as in appendElement, the 'name' argument can
\&        be replaced by an XML string which describes the element.
.Ve
.PP
.Vb 2
\&        Note: to add an element to the end of a document, it would obviously
\&        be better to use appendElement.
.Ve
.PP
\fI\fIisOpenDocument()\fI\fR
.IX Subsection "isOpenDocument()"
.PP
.Vb 4
\&        Returns 1 (true) if the current document is an OASIS Open Document.
\&        To be used every time the application  needs to know the format of
\&        the document, knowing that some differences between the two formats
\&        can't be completely hidden by the API.
.Ve
.PP
\fIlineBreak\fR
.IX Subsection "lineBreak"
.PP
.Vb 4
\&        Returns a special line break element, available for insertion within
\&        an existing text element (knowing that "\en" is not recognized as a
\&        line break if stored "as is"). The returned element is free, so it
\&        could/should be inserted later within a text element.
.Ve
.PP
\fImakeXPath(expression)\fR
.IX Subsection "makeXPath(expression)"
.PP
\fImakeXPath(context, expression)\fR
.IX Subsection "makeXPath(context, expression)"
.PP
.Vb 6
\&        Low-level method allowing the creation or direct modification
\&        without restriction (almost) of any document element. It allows
\&        "query" expressions in a language similar to XPath. If the given
\&        XPath expression crosses several levels of hierarchy, intermediate
\&        nodes can be created or modified "on the fly" by creating the
\&        necessary path which in turn creates the final node.
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 4
\&            $doc->makeXPath
\&             (
\&             '//office:body/text:p[4 @text:style-name="Text body"]'
\&             );
.Ve
.PP
.Vb 4
\&        This "query" applies the "Text body" style to paragraph 4 in the
\&        body of the document. (In reality you will probably never use it
\&        because the setStyle method of the Text module would do the same
\&        thing much more simply.)
.Ve
.PP
.Vb 4
\&        If, as in the above example, a node is accompanied by a position
\&        indicator, it cannot be created but must simply act as a mandatory
\&        "passage". This method cannot therefore be used to create, for
\&        example, an Nth paragraph if there is already an N-1.
.Ve
.PP
.Vb 5
\&        The only restrictions apply to namespaces which are given as
\&        prefixes to element and attribute names. They must be defined in the
\&        document i.e. conform to OpenDocument specifications. For the rest,
\&        this method allows the creation of almost anything anywhere within a
\&        document. Its use is reserved for OpenDocument XML specialists.
.Ve
.PP
.Vb 4
\&        In its second form, a context node can be given as the first
\&        argument. If present, the path is sought (and if necessary created)
\&        starting from its position. By default, the path begins from the
\&        root.
.Ve
.PP
.Vb 1
\&        The returned value is the final node's reference (found or created).
.Ve
.PP
.Vb 3
\&        The full "query language" syntax used in this method is not
\&        documented here. makeXPath is designed to act more as a base for
\&        other OpenOffice::OODoc methods than to be used in applications.
.Ve
.PP
\fImoveElements(target_element, element_list)\fR
.IX Subsection "moveElements(target_element, element_list)"
.PP
.Vb 1
\&        Moves a list of existing elements to a new attachment.
.Ve
.PP
.Vb 2
\&        One more elements are cut from their previous place and appended
\&        as children of the target element.
.Ve
.PP
.Vb 3
\&        This method can be used to move elements from one place to another
\&        place in the same document, as well as from one document to another
\&        one (caution, the elements are moved, not copied).
.Ve
.PP
\fIraw_import(member, source)\fR
.IX Subsection "raw_import(member, source)"
.PP
.Vb 9
\&        Physically imports an external file into an OpenDocument archive
\&        associated with an XPath object, if it exists i.e. if the object was
\&        created using file or archive parameters. This method only transmits
\&        the command to the OODoc::File's raw_import method. Caution: it must
\&        not be used with an "active" element i.e. an XML member to which the
\&        current XPath object or another XPath object is already associated.
\&        Remember too that the import is not actually carried out by
\&        OODoc::File until a save and the imported data is therefore not
\&        immediately available.
.Ve
.PP
\fIraw_export(member, target)\fR
.IX Subsection "raw_export(member, target)"
.PP
.Vb 4
\&        Physically exports a member from an OpenDocument archive associated
\&        with an XPath object, if it exists i.e. if the object was created
\&        using file or archive parameters. This method only transmits the
\&        command to the OODoc::File's raw_import method.
.Ve
.PP
\fIremoveAttribute(path, position, attribute)\fR
.IX Subsection "removeAttribute(path, position, attribute)"
.PP
\fIremoveAttribute(element, attribute)\fR
.IX Subsection "removeAttribute(element, attribute)"
.PP
.Vb 4
\&        Deletes the "attribute" attribute (if found) of the given element by
\&        [path, position] or by reference and returns "true". Has no physical
\&        effect and returns undef if the attribute has not been defined or if
\&        the element does not exist.
.Ve
.PP
\fIremoveElement(path, position)\fR
.IX Subsection "removeElement(path, position)"
.PP
\fIremoveElement(element)\fR
.IX Subsection "removeElement(element)"
.PP
.Vb 3
\&        Deletes the given element (if found) by [path, position] or by
\&        reference and returns "true". Returns undef if the element does not
\&        exist.
.Ve
.PP
\fIreplaceElement(path, position, replacement [, options])\fR
.IX Subsection "replaceElement(path, position, replacement [, options])"
.PP
\fIreplaceElement(old_element, new_element [, options])\fR
.IX Subsection "replaceElement(old_element, new_element [, options])"
.PP
.Vb 3
\&        Deletes the given element by [path, position] or by reference and
\&        inserts another element in its place, either from another location
\&        in the same document or from another document.
.Ve
.PP
.Vb 2
\&        A new element can be supplied under the same conditions as for
\&        insertElement.
.Ve
.PP
.Vb 5
\&        By default or by using the mode => 'copy' option, it is a copy of
\&        the new element which is inserted. With the mode => 'reference'
\&        option, it is only a reference which is inserted. See the section on
\&        appendElement for comments on the subject of multiple references to
\&        a single physical element.
.Ve
.PP
\fIreplaceText(path, position, filter, replacement)\fR
.IX Subsection "replaceText(path, position, filter, replacement)"
.PP
\fIreplaceText(element, filter, replacement)\fR
.IX Subsection "replaceText(element, filter, replacement)"
.PP
.Vb 4
\&        Replaces all sub-strings which match "filter" with "replacement" in
\&        the text of an element (and its descendants) indicated by
\&        [path, position] or by reference and returns the modified text. The
\&        "filter" string can be an "exact" literal or a regular expression.
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 1
\&            $doc->replaceText($p, "C(LIENT|USTOMER)", $contact);
.Ve
.PP
.Vb 2
\&        replaces each occurrence of "CLIENT" and "CUSTOMER" with the content
\&        of the $contact variable in the paragraph $p of document $doc.
.Ve
.PP
.Vb 3
\&        The "replacement" argument can be a function reference. In which
\&        case, the function is called each time the string is matched, and
\&        the value returned by the function is used as the replacement value.
.Ve
.PP
.Vb 7
\&                sub action      {
\&                        my $arg = shift;
\&                        my $text = shift;
\&                        print "$arg : $text\en";
\&                        return "OK";
\&                        }
\&                $doc->replaceText($p, $expression, \e&action, "Found");
.Ve
.PP
.Vb 6
\&        displays "Found: <text>" (where <text> is the text retrieved) each
\&        time a string matches $expression and replaces this string with
\&        "OK". If $expression contains an "exact" string (not a regexp), then
\&        clearly the text displayed will always be the same string. However,
\&        if it happens to be a regular expression, it is in effect the text
\&        retrieved which will be displayed.
.Ve
.PP
.Vb 3
\&        Generally speaking, if the replacement value is a function
\&        reference, the called function receives the remainder of the
\&        arguments which follow it, in this order:
.Ve
.PP
.Vb 2
\&        1) all the arguments following the function reference in the
\&        replaceText() call, in the same order;
.Ve
.PP
.Vb 1
\&        2) the string that matches the filter argument.
.Ve
.PP
.Vb 2
\&        See also substituteText(), which should be preferred in most
\&        situations.
.Ve
.PP
\fIreplicateElement(original_element, position_object [, options]])\fR
.IX Subsection "replicateElement(original_element, position_object [, options]])"
.PP
.Vb 3
\&        Makes a copy of the first given element and inserts it into the
\&        current document at a position which depends on the second argument
\&        and an optional parameter.
.Ve
.PP
.Vb 2
\&        If the second argument is an existing object in the document, then
\&        the copy is inserted according to an optional 'position' parameter:
.Ve
.PP
.Vb 2
\&        - if no 'position' option is provided, then the copy is appended
\&        as the last child of the position object;
.Ve
.PP
.Vb 3
\&        - if 'position' => 'before' or 'after', then the copy is inserted at
\&        the same hierarchical level as the position object, according to the
\&        same logic as for insertElement().
.Ve
.PP
.Vb 4
\&        If the second argument is not an object, but simply 'end', then the
\&        new element is appended as the very last child of the physical root
\&        of the document. See getRoot(). This option should generally be
\&        avoided.
.Ve
.PP
.Vb 3
\&        If the second argument is given as 'body', then the new element
\&        is appended at the end of the document body (see getBody), as it was
\&        created through appendElement().
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 9
\&            my $template = $doc_source->selectElementByAttribute
\&                        (
\&                        '//style::style',
\&                        'style:name',
\&                        'Text body'
\&                        );
\&            my $position = $doc_target->getElement
\&                        ('//office:styles', 0);
\&            $doc_target->replicateElement($template, $position);
.Ve
.PP
.Vb 6
\&        This sequence adds a style 'Text body' to the style set of $doc_target
\&        which copies exactly the style of the same name in $doc_source.
\&        Obviously, the section of code dealing with the search for the element
\&        to copy and its position is the most laborious. (In a real application,
\&        thanks to OODoc::Styles, a more user-friendly coding would be allowed
\&        for style replication.)
.Ve
.PP
.Vb 2
\&        This method creates a new element which is an exact copy of the given
\&        element, but which is physically separate from it.
.Ve
.PP
.Vb 2
\&        This method is slower than simply modifying an existing element or
\&        inserting an element reference.
.Ve
.PP
.Vb 3
\&        If the user needs only a "free" copy of the element (out of the
\&        document structure, to be later attached), the XML::Twig::Elt copy()
\&        method should be preferred:
.Ve
.PP
.Vb 1
\&            my $new_element = $old_element->copy;
.Ve
.PP
\fI\fIresetCurrentContext()\fI\fR
.IX Subsection "resetCurrentContext()"
.PP
.Vb 2
\&        Resets the search context to its default value, which is the root of
\&        the document. See currentContext().
.Ve
.PP
\fIsave([filename])\fR
.IX Subsection "save([filename])"
.PP
.Vb 2
\&        Saves the content of the current document through a physical
\&        output.
.Ve
.PP
.Vb 2
\&        The behaviour of this method depends on the way the current
\&        OpenOffice::OODoc::XPath object has been created.
.Ve
.PP
.Vb 4
\&        If the document is explicitly linked (through the 'file' option
\&        of it's constructor) to a regular OOo or OpenDocument file, the
\&        document is saved either in the source file, or (if a filename
\&        is provided as an argument) in a new file.
.Ve
.PP
.Vb 5
\&        If the document is linked to the same file interface as one or
\&        more other OpenOffice::OODoc::XPath objects, the behaviour is
\&        the same as in the previous case, but all the changes made by
\&        all the linked objects are automatically saved in the target
\&        file. Example:
.Ve
.PP
.Vb 19
\&                my $content     = ooXPath
\&                                (
\&                                file    => 'source.odt',
\&                                member  => 'content'
\&                                );
\&                my $styles      = ooXPath
\&                                (
\&                                file    => $content,
\&                                member  => 'styles'
\&                                )
\&                my $meta        = ooXPath
\&                                (
\&                                file    => $content,
\&                                member  => 'meta'
\&                                );
\&                # ... a lot of content processing
\&                # ... a lot of style processing
\&                # ... a lot of metadata processing
\&                $content->save('target.odt');
.Ve
.PP
.Vb 6
\&        At the end of the sequence above, all the changes made through
\&        the $content, $styles and $meta objects are saved in 'target.odt'
\&        because these objects share a common file interface. Note that
\&        in such a situation, the save() method can be issued from anyone
\&        of the objects sharing the file interface (i.e. $content->save
\&        could be replaced by $styles->save or $meta->save).
.Ve
.PP
.Vb 5
\&        However, any XML member (content, styles, meta, ...) whose
\&        'read_only' property is set to "true" is not saved. In the example
\&        above, if, say, the $meta object is created (through ooXPath())
\&        with a "read_only" option set to "true", only $content and $styles
\&        are really saved by the last instruction.
.Ve
.PP
.Vb 4
\&        Note: OpenOffice::OODoc::XPath doesn't really know anything about
\&        the physical archive file; here save() is only a stub method and
\&        the real job is done by the save() method of the associated
\&        OpenOffice::OODoc::File object.
.Ve
.PP
.Vb 6
\&        If the document is not associated with a regular OpenDocument
\&        compressed file (used through an OODoc::File object), it's saved
\&        as "flat XML" to the given file. In such a situation, if the file name
\&        is not provided, the source XML file (if any) is used as the target.
\&        If the file is "flat XML", OODoc::XPath really effects the physical
\&        output, without using any OODoc::File connector.
.Ve
.PP
.Vb 3
\&        Note: if you need to save a document as flat XML while it's associated
\&        with an OpenDocument file, you should use exportXMLContent() with an
\&        application-provided file handle.
.Ve
.PP
\fIselectChildElementByName(path, position [, filter])\fR
.IX Subsection "selectChildElementByName(path, position [, filter])"
.PP
\fIselectChildElementByName(element [, filter])\fR
.IX Subsection "selectChildElementByName(element [, filter])"
.PP
.Vb 3
\&        Returns the first (or only) element whose name matches "filter" from
\&        within the child elements of the given element indicated by [path,
\&        position] or by reference.
.Ve
.PP
.Vb 5
\&        "filter" is taken to be a regular expression. If several values
\&        match the filter, the first of these is returned (in the XML's
\&        physical order which is not necessarily the logical order of the
\&        document). See the comments about selectElementByAttribute if
\&        wanting to select an exact name.
.Ve
.PP
.Vb 1
\&        Returns undef if no elements match the condition.
.Ve
.PP
.Vb 3
\&        Returns the first (or only) child (if there are more than one)
\&        without anything else if no filter is given or if the filter uses
\&        wildcards (".*").
.Ve
.PP
\fIselectChildElementsByName(path, position [, filter])\fR
.IX Subsection "selectChildElementsByName(path, position [, filter])"
.PP
\fIselectChildElementsByName(element [, filter])\fR
.IX Subsection "selectChildElementsByName(element [, filter])"
.PP
.Vb 2
\&        Like selectChildElementByName, but returns a list of all elements
\&        which match the condition.
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 3
\&            my @search_words =
\&                $doc->selectChildElementsByName
\&                        ('//text:p', 4, 'text:span');
.Ve
.PP
.Vb 3
\&        returns a list of elements from paragraph 4 which correspond to text
\&        which has particular attributes which distinguish it from the rest
\&        of the paragraph (colour, font, etc.)
.Ve
.PP
\fIselectElements([context,] path, filter)\fR
.IX Subsection "selectElements([context,] path, filter)"
.PP
\fIselectElements([context,] path, filter, replacement)\fR
.IX Subsection "selectElements([context,] path, filter, replacement)"
.PP
\fIselectElements([context,] path, filter, action [, arg1, ...])\fR
.IX Subsection "selectElements([context,] path, filter, action [, arg1, ...])"
.PP
.Vb 5
\&        Returns a list of elements corresponding to a given XPath path and
\&        whose text matches the filter (regular expression). The "context"
\&        argument, if given, is an element reference which limits the search
\&        to its own child elements. The search is carried out in the entire
\&        document by default.
.Ve
.PP
.Vb 4
\&        An element is selected if the search string is found in its own text
\&        or in the text of any element descended from it. E.g. An image
\&        element (draw:image) can be selected from the value of its attached
\&        "description" field.
.Ve
.PP
.Vb 3
\&        You can replace all strings matching the search criteria with the
\&        'replacement' string, on the fly, if the latter is given as an
\&        argument after the filter.
.Ve
.PP
.Vb 5
\&        Lastly, instead of a replacement string, you can pass a subroutine's
\&        reference which will run (in call back mode) each time the search
\&        string is matched. If this subroutine returns a defined value, this
\&        value is used as the replacement string. The subroutine will
\&        automatically receive the rest of the arguments, in this order:
.Ve
.PP
.Vb 5
\&        Caution: this method can't retrieve a character string which is
\&        split into more than one text element or text span. So, for example,
\&        it will never retrieve "My String" as long as "My" and "String" are
\&        presented with different styles, even if the two parts of the string
\&        belong to the same paragraph.
.Ve
.PP
.Vb 4
\&        If, as is generally the case, you are working exclusively with text
\&        elements (paragraphs, headers, etc.), you would be better to use
\&        selectElementsByContent() of the Text module which is easier to use
\&        and does not require an XPath expression.
.Ve
.PP
.Vb 3
\&        Here is an example which returns the list of images whose
\&        descriptors contain the word "landscape" and displays the name of
\&        each selected image:
.Ve
.PP
.Vb 14
\&            sub printMessage
\&                {
\&                my $doc         = shift;
\&                my $element     = shift;
\&                my $image = $element->parentNode;
\&                print "Name: " . $image->find('@draw:name') . "\en";
\&                }
\&            my @list = $doc->selectElements
\&                (
\&                '//draw:image/svg:desc',
\&                'landscape',
\&                \e&printMessage,
\&                $doc
\&                );
.Ve
.PP
.Vb 3
\&        Never use this example of code in a real application as it is both
\&        purely for demonstration and unnecessarily complex. You can perform
\&        the same operation much more simply using the OODoc::Image module.
.Ve
.PP
\fIselectElementsByAttribute(path, attribute, filter)\fR
.IX Subsection "selectElementsByAttribute(path, attribute, filter)"
.PP
.Vb 3
\&        In a list context, returns a list of elements at the given path with
\&        the given attribute which contain a value matching the filter's
\&        regular expression.
.Ve
.PP
.Vb 2
\&        In a scalar context, returns the first (or only) element which
\&        matches the same condition.
.Ve
.PP
.Vb 1
\&        Returns undef if no elements match the condition.
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 3
\&            my @paragraph_styles =
\&             $doc->selectElementsByAttribute
\&                ('style:style', 'style:family', 'paragraph');
.Ve
.PP
.Vb 2
\&        returns the list of elements which describe the paragraph styles of
\&        document $doc.
.Ve
.PP
.Vb 7
\&        Caution: the filter is treated as a regular expression and not as a
\&        classic string. This means that the above piece of code might not
\&        only return the elements whose "style:family" attribute equals
\&        "paragraph", but also all those in which the same attribute contains
\&        the word "paragraph". You must therefore use the appropriate syntax
\&        (in regexp language) if you want to select an exact value, which in
\&        this case would be "^paragraph$".
.Ve
.PP
\fIselectElementByAttribute(path, attribute, value)\fR
.IX Subsection "selectElementByAttribute(path, attribute, value)"
.PP
.Vb 3
\&        Like selectElementsByAttribute in a scalar context. Returns the
\&        first (or only) element at the given path which has the given
\&        attribute containing the given value.
.Ve
.PP
.Vb 1
\&        Returns undef if no element matches the condition.
.Ve
.PP
\fIselectNodesByXPath(xpath_expression)\fR
.IX Subsection "selectNodesByXPath(xpath_expression)"
.PP
.Vb 3
\&        This low-level method returns a list of nodes (which are not
\&        necessarily elements) which match the give XPath expression. See
\&        getNodeByXPath() for options and comments.
.Ve
.PP
\fIsetAttributes(path, position, attributes_table)\fR
.IX Subsection "setAttributes(path, position, attributes_table)"
.PP
\fIsetAttributes(element, attributes_table)\fR
.IX Subsection "setAttributes(element, attributes_table)"
.PP
.Vb 1
\&        Modifies or adds one or more attributes to an element.
.Ve
.PP
.Vb 1
\&        The element is indicated by reference or by [path, position].
.Ve
.PP
.Vb 1
\&        The list of attributes is given in the form of a hash name => value.
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 7
\&            my $h = $doc->getElement('//text:h', 12);
\&            my %attributes =
\&                (
\&                'text:style-name'       => 'My Header',
\&                'text:level             => '3'
\&                );
\&            $doc->setAttributes($h, %attributes);
.Ve
.PP
.Vb 2
\&        This sequence gives the 'My Header' style and level 3 to the 13th
\&        "header" element in the document.
.Ve
.PP
\fIsetFlatText(path, position, text)\fR
.IX Subsection "setFlatText(path, position, text)"
.PP
\fIsetFlatText(element, text)\fR
.IX Subsection "setFlatText(element, text)"
.PP
.Vb 2
\&        Like setText() described below, but without translation of "\et"
\&        and "\en".
.Ve
.PP
.Vb 2
\&        For exceptional use only. Allows, for example, the use of the OODoc
\&        API with non-OpenDocument XML files.
.Ve
.PP
\fIsetObjectCoordinates(object, coordinates)\fR
.IX Subsection "setObjectCoordinates(object, coordinates)"
.PP
.Vb 3
\&        Updates or creates the coordinates (X, Y) attributes of a visible
\&        object (ex: image, text box, frame). See createFrameElement() for the
\&        coordinates units and notation.
.Ve
.PP
\fIsetObjectDescription(object, description)\fR
.IX Subsection "setObjectDescription(object, description)"
.PP
.Vb 1
\&        Updates or creates the litteral description of the given object.
.Ve
.PP
.Vb 3
\&        Should be used for frames, images or text boxes. Caution: the
\&        description is not the same as the printable content of a text
\&        box.
.Ve
.PP
\fIsetObjectSize(object, size)\fR
.IX Subsection "setObjectSize(object, size)"
.PP
.Vb 1
\&        Updates or creates the width and height attributes of a given object.
.Ve
.PP
.Vb 2
\&        This method makes sense for visible, rectangular objects only, such
\&        as the frames, images or text boxes.
.Ve
.PP
.Vb 2
\&        See createFrameElement() for details about the size units and
\&        notation.
.Ve
.PP
\fIsetText(path, position, text)\fR
.IX Subsection "setText(path, position, text)"
.PP
\fIsetText(element, text)\fR
.IX Subsection "setText(element, text)"
.PP
.Vb 1
\&        Uses the given text as the content of the given element.
.Ve
.PP
.Vb 2
\&        Any previous content (including formatting markup, bookmarks,
\&        notes, references, etc) is replaced by the given text.
.Ve
.PP
.Vb 3
\&        If the given text includes tab stops ("\et") or line breaks ("\en"),
\&        they are replaced by the appropriate OpenDocument tags. If this
\&        translation must be avoided, use setFlatText() instead.
.Ve
.PP
.Vb 3
\&        Note: The strings containing repeated spaces are not properly
\&        processed. A sequence of repeated spaces, whatever its length,
\&        is replaced by a single space in the target document. So
.Ve
.PP
.Vb 1
\&                $doc->setText($p, "Begin        End");
.Ve
.PP
.Vb 1
\&        produces the same visible result as
.Ve
.PP
.Vb 1
\&                $doc->setText($p, "Begin End");
.Ve
.PP
.Vb 2
\&        See spaces() and extendText() for a workaround if you
\&        need to insert repeated spaces.
.Ve
.PP
\fIspaces(length)\fR
.IX Subsection "spaces(length)"
.PP
.Vb 6
\&        Returns a special element, available for insertion within a text
\&        element, representing repeated contiguous blank spaces (knowing
\&        that repeated spaces can't be properly displayed by an OpenDocument-
\&        compliant application if stored as a flat string). The returned
\&        element is free, so it could/should be inserted later within a text
\&        element. See extendText() for an example of use.
.Ve
.PP
\fIsplitElement(element, offset)\fR
.IX Subsection "splitElement(element, offset)"
.PP
.Vb 5
\&        Splits a text element at a given offset. This method is a wrapper
\&        of the XML::Twig::Elt split_at() method, so, as said by Michel
\&        Rodriguez in his documentation, it splits "a text element in 2" at
\&        the given offset so "the original element now holds the first part
\&        of the string and a new element holds the right part".
.Ve
.PP
.Vb 2
\&        In addition, the new element is created with the same attributes (ex:
\&        the style or the heading level, if any) as the original one.
.Ve
.PP
.Vb 2
\&        The method returns both the original and the new elements in a list
\&        context. In a scalar context, the new element only is returned.
.Ve
.PP
.Vb 4
\&        The new element is "free", i.e. it doesn't belong to the document.
\&        It's available for later use with any element attachment method,
\&        provided by OpenOffice::OODoc (appendElement(), insertElement()) or
\&        by XML::Twig (paste()). Example:
.Ve
.PP
.Vb 2
\&                my $new_elt = $doc->splitElement($para, 12);
\&                $doc->insertElement($para, $new_elt, position => 'after');
.Ve
.PP
.Vb 1
\&        This example splits the given paragraph in two consecutive paragraphs.
.Ve
.PP
.Vb 5
\&        Caution: splitElement() works properly on elements containing "flat
\&        text" only. It's a bit complicated to use and probably doesn't
\&        produce the right effects on elements containing line breaks, tab
\&        stops, "styled spans" or any kind of structure. So, it should be used
\&        on flat paragraphs or headings only.
.Ve
.PP
\fIsubstituteText(element, filter, replacement)\fR
.IX Subsection "substituteText(element, filter, replacement)"
.PP
.Vb 2
\&        Replaces any substring in a given element and its descendant, matching
\&        a given filter (regexp) by a given replacement string.
.Ve
.PP
.Vb 2
\&        It "replacement" is a string, this method produces the same result as
\&        replaceText(), and it should be preferred.
.Ve
.PP
.Vb 3
\&        If "replacement" is a function reference, the replacement value is the
\&        return value of the function. But, unlike replaceText(), any argument
\&        after "replacement" is ignored.
.Ve
.PP
.Vb 3
\&        This method is a wrapper for the subs_text() method provided by the
\&        XML::Twig::Elt class. See the XML::Twig documentation for advanced
\&        details.
.Ve
.PP
\fItabStop\fR
.IX Subsection "tabStop"
.PP
.Vb 4
\&        Returns a special tabulation mark element, available for insertion
\&        within an existing text element (knowing that "\et" is not recognized
\&        as a tab stop if stored "as is"). The returned element is free, so
\&        it could/should be inserted later within a text element.
.Ve
.Sh "Element methods"
.IX Subsection "Element methods"
.Vb 6
\&        Every document element is an OpenOffice::OODoc::Element object,
\&        and OpenOffice::OODoc::Element inherits all the rich features of
\&        XML::Twig::Elt, including the very powerful copy(), cut(), paste(),
\&        move() and replace() methods (look at the XML::Twig documentation
\&        for details). Some additional methods, provided in the ::Element
\&        package, are described below.
.Ve
.PP
.Vb 4
\&        The "element methods" should be regarded as reserved for advanced
\&        uses, possibly in combination with native XML::Twig::Elt methods
\&        (not documented here, but the XML::Twig package itself is well
\&        documented).
.Ve
.PP
.Vb 2
\&        Remember these methods belong to the element and not to the
\&        document...!
.Ve
.PP
\fIappendChild(newnode)\fR
.IX Subsection "appendChild(newnode)"
.PP
.Vb 1
\&        Appends a node as the last child of the calling node.
.Ve
.PP
.Vb 3
\&        If the argument is an existing node, it's appended as is.
\&        If the argument is a string, a new node is created, with the
\&        given string as the XML tag name.
.Ve
.PP
\fIappendTextChild(text)\fR
.IX Subsection "appendTextChild(text)"
.PP
.Vb 2
\&        Appends a text node (PCDATA) as the last child of the calling
\&        element.
.Ve
.PP
\fI\fIflatten()\fI\fR
.IX Subsection "flatten()"
.PP
.Vb 9
\&        Converts in place the content of the calling element to a flat string,
\&        removing any structure. All the children of the calling element are
\&        removed and their text content is concatenated. The resulting string
\&        becomes the only content of the element. For example, if the calling
\&        element is a table, the tabular structure disappears and is replaced
\&        by the concatenated contents of all the cells. Any possible internal
\&        tab stop or line break element is removed, as well as any "styled"
\&        text span (see setSpan() and removeSpan() is the OODoc::Text chapter
\&        for information about styled text spans).
.Ve
.PP
.Vb 8
\&        Be careful, a lot of elements are not displayed by the OpenDocument
\&        compliant software. For example, a section element becomes invisible
\&        if it directly contains its text, without structure elements such as
\&        paragraphs, headings, tables, and so on. In order to make visible the
\&        "flattened" content of a previously complex element, the XML tag
\&        should be replaced by the tag of a "displayable" element. In the
\&        following example, a section is flattened, then tagged as a
\&        paragraph, so its content remains visible:
.Ve
.PP
.Vb 3
\&                my $s = $doc->getSection("AnySection");
\&                $s->flatten;
\&                $s->set_tag('text:p');
.Ve
.PP
.Vb 2
\&        Note: getSection() belongs to OpenOffice::OODoc::Text and set_tag()
\&        is provided by the underlying XML::Twig::Elt package.
.Ve
.PP
.Vb 9
\&        The text flattening is sometimes required in order to allow the
\&        applications to retrieve strings which are split into more than one
\&        text container. For example, a string such as "OpenDocument" can't
\&        be retrieved using selectElements() or any other string search method
\&        of the API if, say, "Open" and "Office" don't belong to the same text
\&        span (i.e. if they have different styles; look at setSpan() in
\&        OpenOffice::OODoc::Text to know more about text spans). In such a
\&        situation, flatten() removes any text span markup, so the whole text
\&        content of the element can be processed as a regular character string.
.Ve
.PP
.Vb 1
\&        Caution, this method can produce terrific results when misused.
.Ve
.PP
\fIgetLocalPosition([regexp])\fR
.IX Subsection "getLocalPosition([regexp])"
.PP
.Vb 2
\&        Returns the position of the current element in the list of all
\&        the children of the same parent with the same type.
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 1
\&                $cell->getLocalPosition();
.Ve
.PP
.Vb 2
\&        Assuming $cell is a table cell, this example returns the position
\&        of the cell in the row without counting the covered cells (if any).
.Ve
.PP
.Vb 4
\&        If a regular expression is provided as the optional argument, all
\&        the siblings matching the expression are counted; but the method
\&        returns zero if the calling element itself doesn't match the
\&        expression.
.Ve
.PP
.Vb 1
\&        Example:
.Ve
.PP
.Vb 1
\&                $cell->getLocalPosition(qr'table:(covered-|)table-cell');
.Ve
.PP
.Vb 2
\&        returns the position of the cell among all the cells (covered or not)
\&        in the row.
.Ve
.PP
.Vb 3
\&        Note: This method is a wrapper of the pos() method of XML::Twig::Elt,
\&        but the returned values are zero-based in order to be consistent
\&        with the other element addressing features of OpenOffice::OODoc.
.Ve
.PP
\fIinsertNewNode(xml_tag, position_flag [, offset])\fR
.IX Subsection "insertNewNode(xml_tag, position_flag [, offset])"
.PP
.Vb 5
\&        Creates a new XML element, whose tag is passed as the 1st argument,
\&        before, after or within the calling element. The 2nd argument
\&        must be set to 'before', 'after', 'within', or any other value
\&        accepted by the paste() method of XML::Twig. If the 2nd argument
\&        is 'within', a 3rd one must be provided and indicate the offset.
.Ve
.PP
\fIreplicateNode(count, position)\fR
.IX Subsection "replicateNode(count, position)"
.PP
.Vb 8
\&        Produces one or more copies of the calling element and inserts
\&        the copies before or after it. The position argument should be
\&        'before' or 'after'; its default is 'after'. Technically, the
\&        position argument could be anyone of the position options of
\&        the XML::Twig::Elt->paste method, including 'first_child',
\&        'last_child' or 'within'; but any other than 'before' and 'after'
\&        probably don't make sense in an OpenDocument-compliant data
\&        structure.
.Ve
.PP
.Vb 3
\&        Without any argument, the calling element is replicated once.
\&        But if the count argument is provided and set to zero or a
\&        negative value, nothing is done.
.Ve
.PP
.Vb 1
\&        Example :
.Ve
.PP
.Vb 2
\&                my $row = $doc->getTableRow("Table1", -1);
\&                $row->replicateNode(5);
.Ve
.PP
.Vb 3
\&        This sequence appends 5 more rows to a table; each new row is a
\&        copy of the last original row, including each individual cell
\&        and its content.
.Ve
.PP
\fIselectChildElement(filter)\fR
.IX Subsection "selectChildElement(filter)"
.PP
.Vb 2
\&        Like selectChildElements() below, but returns only the first node
\&        matching the filter.
.Ve
.PP
.Vb 2
\&        Note: the first_child() method of XML::Twig::Elt should be preferred
\&        when the filter is the exact tag name of the needed element.
.Ve
.PP
\fIselectChildElements(filter)\fR
.IX Subsection "selectChildElements(filter)"
.PP
.Vb 2
\&        Selects the children with XML tag names matching a given filter.
\&        The filter is processed as a regexp.
.Ve
.PP
.Vb 2
\&        Note: the children() method of XML::Twig::Elt should be preferred
\&        if the filter is the exact tag name of the needed elements.
.Ve
.PP
\fIselectFrameElementByName(name)\fR
.IX Subsection "selectFrameElementByName(name)"
.PP
.Vb 3
\&        Selects the first frame element whose name is exactly the given
\&        argument. A frame is an OpenDocument container which can host a
\&        rectangular object, such as an image or a text box.
.Ve
.Sh "Properties"
.IX Subsection "Properties"
.Vb 2
\&        No class variables are exported; the applications, if needed,
\&        must access them using their full name ($OpenOffice::OODoc::XPath:XXX)
.Ve
.PP
.Vb 2
\&        The following names should be prefixed explicitly with
\&        "$OpenOffice::OODoc::XPath::"
.Ve
.PP
.Vb 1
\&            CHARS_TO_ESCAPE
.Ve
.PP
.Vb 2
\&        contains the list of reserved characters which, in XML, should be
\&        replaced by escape sequences.
.Ve
.PP
.Vb 1
\&            OO_CHARSET
.Ve
.PP
.Vb 2
\&        indicates the character set used for OpenDocument document
\&        encoding and whose default value is 'utf8' (it should not be changed).
.Ve
.PP
.Vb 1
\&            LOCAL_CHARSET
.Ve
.PP
.Vb 7
\&        indicates the user's character set, by default 'iso-8859-1'; it must
\&        be changed according to the real user's needs (warning: there is no
\&        kind of automatic adaptation to the user's locales, so the application
\&        must explicitly load the right value in this variable); it should be
\&        done using the ooLocalEncoding() accessor (see the OpenOffice::OODoc
\&        man page and, for the list of supported character sets, the Encode
\&        module's documentation).
.Ve
.PP
.Vb 2
\&        The content of these three variables should not normally be directly
\&        modified by the applications.
.Ve
.PP
.Vb 1
\&        Instance hash variables are :
.Ve
.PP
.Vb 10
\&            'archive'           => <oodoc_file_object>
\&            'file'              => <OpenDocument file>
\&            'member'            => <file member>
\&            'readable_XML'      => <'true' or 'false'>
\&            'local_encoding'    => <user's output encoding>
\&            'xml'               => <XML string>
\&            'element'           => <name of loaded XML element>
\&            'xpath'             => <XML::Twig object>
\&            'twig_options'      => <XML::Twig options as a hash reference>
\&            'opendocument'      => <'true' or 'false'>
.Ve
.PP
.Vb 4
\&        However, the 'xml' variable is cleared almost immediately after a
\&        successful constructor call, in order to save memory. As soon as the
\&        corresponding XPath object has been created, the XML source is no
\&        longer required.
.Ve
.PP
.Vb 5
\&        The 'xpath' variable of an OODoc::XPath object contains a reference
\&        to the document structure as it's made available through XML::Twig
\&        (see CPAN documentation). This object encompasses the entire current
\&        XML tree. Each access to XML using OODoc::XPath objects is done via
\&        XML::Twig. So, after having run the following command:
.Ve
.PP
.Vb 1
\&            my $xp = $doc->{'xpath'};
.Ve
.PP
.Vb 4
\&        the experienced programmer will be able to use $xp to access all the
\&        functionality of the XML::Twig API, bearing in mind that all
\&        operations using this interface will have a direct effect on the
\&        content of the $doc object.
.Ve
.PP
.Vb 4
\&        'twig_options' allows the user to provide a hash reference of
\&        additional options to XML::Twig. These options can modify the way the
\&        document is parsed during the execution of ooXPath. For special
\&        applications only (see the XML::Twig reference manual).
.Ve
.PP
.Vb 5
\&        The 'opendocument' property, if true, means that the document is
\&        declared as an OASIS Open Document. If this property is false or
\&        undef, the document format is OpenOffice.org version 1. This property
\&        should not be changed (as long as OpenOffice::OODoc can't change the
\&        format of an existing document).
.Ve
.SH "AUTHOR/COPYRIGHT"
.IX Header "AUTHOR/COPYRIGHT"
Developer/Maintainer: Jean-Marie Gouarne <http://jean.marie.gouarne.online.fr>
.PP
Contact: jmgdoc@cpan.org
.PP
Copyright 2004\-2007 by Genicorp, S.A. <http://www.genicorp.com>
.PP
Initial English version of the reference manual by Graeme A. Hunter
(graeme.hunter@zen.co.uk).
.PP
License:
.PP
.Vb 2
\&        - Licence Publique Generale Genicorp v1.0
\&        - GNU Lesser General Public License v2.1
.Ve
